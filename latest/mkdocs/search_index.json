{
    "docs": [
        {
            "location": "/", 
            "text": "DifferentialEquations.jl Documentation\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes algorithms from very recent research, as well as algorithms optimized for HPC applications. It integrates with the Julia package sphere, for example using Juno's progress meter, and wraps other differential equation solvers so that many different methods for solving the equations can be accessed by simply switching a keyword argument.\n\n\nAll of the algorithms are thoroughly tested to ensure accuracy. Convergence tests are included in the \ntest/\n folder. The algorithms were also tested to show correctness with nontrivial behavior such as Turing morphogenesis. Example IJulia notebooks \ncan be found in the examples folder\n. If you find any example where there seems to be an error, please open an issue.\n\n\nIf you have any questions, or just want to chat about solvers/using the package, please feel free to message me in the \nGitter channel\n. For bug reports, feature requests, etc., please submit an issue. If you're interested in contributing, please see the \nContributor's Guide\n.\n\n\n\n\nUsing the Package\n\n\nTo install the package, use the following command inside the Julia REPL:\n\n\nPkg.add(\nDifferentialEquations\n)\n\n\n\n\nFor all of the latest features, switch to the master branch via:\n\n\nPkg.checkout(\nDifferentialEquations\n)\n\n\n\n\nTo load the package, use the command:\n\n\nusing DifferentialEquations\n\n\n\n\nTo understand the package in more detail, check out the following tutorials in the manual. Examples IJulia notebooks using DifferentialEquations can be found \nin the examples folder\n. Codes for the latest features can be found in \ntest/\n.\n\n\nFor the most up to date on using the package information, please contact me \nvia the repository Gitter\n or \nread the latest documentation\n\n\n\n\nSupported Equations\n\n\nFor PDEs, one can optionally specify a noise equation. The solvers currently have stochastic variants for handling Gaussian Space-time white noise SPDEs.\n\n\n\n\nODEs\n\n\nSODEs\n\n\n\n\n(Stochastic) PDEs\n\n\n\n\nLinear Poisson Equation\n\n\nSemi-linear Poisson Equation\n\n\nLinear Heat Equation\n\n\nSemi-linear Heat Equation (aka Reaction-Diffusion Equation)\n\n\nStationary Stokes Equation\n\n\n\n\n\n\n\n\n\n\nImplemented Solvers\n\n\nFor PDEs, [method] denotes an additional version for handling stochastic partial differential equations. SDE solvers and ODE solvers take in general sized inputs. For example, if u\u2080 is a matrix (and your problem functions are designed to work with matrices), then the solver will use the matrices without error.\n\n\n\n\n\n\nODEs\n\n\n\n\n\n\nOptimized Explicit Solvers\n\n\n\n\nEuler\n\n\nMidpoint Method\n\n\n\n\nRK4\n\n\n\n\nGeneral Explicit (Adaptive) Runge-Kutta Methods\n\n\n\n\n\n\n\n\nHuen's Method\n\n\n\n\nCash-Karp\n\n\nRunge-Kutta-Fuhlberg (RKF) 4/5\n\n\nRalston's Method\n\n\nBogaki-Shampine\n\n\nDormand-Prince 4/5\n\n\nRunge-Kutta-Fuhlberg (RKF) 7/8\n\n\n\n\nDormand-Prince 7/8\n\n\n\n\nStiff Solvers. Requires \nNLsolve.jl\n and optionally \nForwardDiff.jl\n. See \nConditional Dependencies\n.\n\n\n\n\n\n\n\n\nImplicit Euler\n\n\n\n\nTrapezoidal\n\n\n\n\nRosenbrock32\n\n\n\n\nWrappers for ODEInterface.jl. See \nConditional Dependencies\n.\n\n\n\n\n\n\n\n\ndorpi5 - Hairer's DP5(4)\n\n\n\n\ndop853 - Hairer's DP8(5,3)\n\n\nodex - Extrapolation algorithm based on explicit midpoint rule\n\n\nradau5 - Implicit Runge-Kutta order 5\n\n\nradau - Implicit Runge-Kutta variable order 5-13\n\n\n\n\nseulex - Extrapolation based on linear implicit Euler\n\n\n\n\nWrappers for ODE.jl. See \nConditional Dependencies\n.\n\n\n\n\n\n\n\n\node23 - Bogacki-Shampine's method\n\n\n\n\node45 - Dormand-Prince  4/5\n\n\node78 - Runge-Kutta-Fuhlberg  7/8\n\n\node23s - Rosenbrock method 2/3\n\n\node1 - Forward Euler\n\n\nmidpoint - Midpoint method\n\n\node2_heun - Huen's method\n\n\node4 - RK4\n\n\node45_fe - Runge-Kutta-Fuhlberg 4/5\n\n\n\n\n\n\n\n\n\n\n\n\nSODEs\n\n\n\n\nEuler-Maruyama\n\n\nMilstein\n\n\nRossler-SRK\n\n\n\n\n\n\n\n\nFinite Element Solvers (Stochastic) PDEs\n\n\n\n\n\n\nSemilinear Poisson Equation\n\n\n\n\n\n\nSee implicit solvers\n\n\n\n\nSemilinear Heat Equation (Reaction-Diffusion)\n\n\n\n\n\n\n\n\nForward Euler [Maruyama]\n\n\n\n\nBackward Euler [Maruyama]\n\n\nSemi-implicit Crank-Nicholson [Maruyama]\n\n\n\n\nSemi-implicit Backward Euler [Maruyama]\n\n\n\n\nLinear Heat Equation\n\n\n\n\n\n\n\n\nForward Euler [Maruyama]\n\n\n\n\nBackward Euler [Maruyama]\n\n\nCrank-Nicholson [Maruyama]\n\n\n\n\n\n\n\n\n\n\n\n\nImplicit Solvers\n\n\n\n\nDirect\n\n\nFactorizations (LU, Cholesky, QR, SVD)\n\n\nConjugate-Gradient (CG)\n\n\nGMRES\n\n\n\n\n\n\n\n\n\n\nRoadmap\n\n\n\n\n\n\nSODE Solvers\n\n\n\n\nAdaptive-SRK\n\n\n\n\n\n\n\n\nFinite difference solvers (Stochastic) PDE Solvers\n\n\n\n\nSemi-linear Heat Equation (Reaction-Diffusion Equation)\n\n\nSemi-linear Poisson Equation\n\n\nWave Equation\n\n\nTransport Equation\n\n\nStokes Equation\n\n\nImplicit Integration Factor (IIF) Maruyama\n\n\nImplicit Integration Factor (IIF) Milstein\n\n\n\n\n\n\n\n\n\n\nIJulia Notebook Tutorials\n\n\nIf you have \nIJulia\n installed, you can access extra tutorials in the supplied IJulia notebooks via:\n\n\nusing IJulia\ncd(Pkg.dir(\nDifferentialEquations\n)*\n/examples\n)\nnotebook()\n\n\n\n\nOtherwise, these notebooks can be viewed \nvia the Github repository\n (note that Github renders them slightly incorrectly, so it will look better in IJulia!).\n\n\n\n\nTutorials\n\n\nThe following tutorials will introduce you to the functionality of DifferentialEquations.jl More examples can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\n\n\nOrdinary Differential Equation (ODE) Example\n\n\nStochastic Differential Equation (SDE) Example\n\n\nPoisson Equation Finite Element Method Example\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\n\n\n\n\nSolver Options\n\n\nThese pages describe the options available in the solvers.\n\n\n\n\nOrdinary Differential Equation Solvers\n\n\nPros and Cons of Different Methods\n\n\n\n\n\n\nStochastic Differential Equation Solvers\n\n\nFinite Element Method Poisson Equation Solvers\n\n\nFinite Element Method Heat Equation Solvers\n\n\n\n\n\n\nFinite Difference Method Stokes Equation Solvers\n\n\nStokes Equation\n\n\n\n\n\n\n\n\n\n\nManual\n\n\n\n\nOverview of DifferentialEquations.jl Usage\n\n\nExtras for Developers and Researchers\n\n\nDefining an ODE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nDefining a SDE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nDefining a FEM Problem\n\n\nPoisson Equation Problem\n\n\nHeat Equation Problem\n\n\nExample Problems\n\n\nRelated Functions\n\n\n\n\n\n\nDefining a Stokes Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nMeshes\n\n\nMesh Specification\n\n\nMesh Type\n\n\nMesh Generation Functions\n\n\nExample Meshes\n\n\nPlot Functions\n\n\n\n\n\n\nThe Solution Type\n\n\nSolution Types\n\n\nRelated Functions\n\n\n\n\n\n\nPlot Functions\n\n\nStandard Plots\n\n\nExtra Plot Functions\n\n\n\n\n\n\nConvergence Simulations\n\n\nThe ConvergenceSimulation Type\n\n\nPlot Functions\n\n\nRelated Functions\n\n\n\n\n\n\nConditional Dependencies\n\n\nThe Conditional Dependency Notification\n\n\nWhat Methods Require Conditional Dependencies?\n\n\nInstallation Instructions\n\n\n\n\n\n\n\n\n\n\nInternal Documentation\n\n\n\n\nContributor's Guide\n\n\nDeveloping New Solver Algorithms\n\n\nAdding Conditional Dependencies\n\n\nDeveloping A New Problem\n\n\nOther Help\n\n\n\n\n\n\nInternal Finite Element Tools\n\n\nGeneral\n\n\nMesh Tools\n\n\nSolver Tools\n\n\nError Tools\n\n\n\n\n\n\nExtra Functions\n\n\nMaking Build Work\n\n\n\n\n\n\nSolver Helpers\n\n\nODE Solver Extras\n\n\nSDE Solver Extras\n\n\nStationary Stokes\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDifferentialEquations\n\n\nDifferentialEquations.ODE_DEFAULT_TABLEAU\n\n\nDifferentialEquations.ConvergenceSimulation\n\n\nDifferentialEquations.DEProblem\n\n\nDifferentialEquations.DESolution\n\n\nDifferentialEquations.ExplicitRK\n\n\nDifferentialEquations.FEMSolution\n\n\nDifferentialEquations.FEMmesh\n\n\nDifferentialEquations.HeatProblem\n\n\nDifferentialEquations.Mesh\n\n\nDifferentialEquations.ODEProblem\n\n\nDifferentialEquations.ODESolution\n\n\nDifferentialEquations.PoissonProblem\n\n\nDifferentialEquations.RosslerSRA\n\n\nDifferentialEquations.RosslerSRI\n\n\nDifferentialEquations.SDEProblem\n\n\nDifferentialEquations.SDESolution\n\n\nDifferentialEquations.SimpleMesh\n\n\nDifferentialEquations.StokesProblem\n\n\nDifferentialEquations.StokesSolution\n\n\nDifferentialEquations.Tableau\n\n\nBase.length\n\n\nBase.length\n\n\nBase.length\n\n\nBase.size\n\n\nDifferentialEquations.CFL\u03bc\n\n\nDifferentialEquations.CFL\u03bd\n\n\nDifferentialEquations.FEMSolutionTS\n\n\nDifferentialEquations.GSu!\n\n\nDifferentialEquations.GSv!\n\n\nDifferentialEquations.GS\u03b4q!\n\n\nDifferentialEquations.additiveSDEExample\n\n\nDifferentialEquations.animate\n\n\nDifferentialEquations.appxTrue!\n\n\nDifferentialEquations.assemblematrix\n\n\nDifferentialEquations.calc_rp!\n\n\nDifferentialEquations.calc\ud835\udcaaestimates\n\n\nDifferentialEquations.checkSRAOrder\n\n\nDifferentialEquations.checkSRIOrder\n\n\nDifferentialEquations.constructBogakiShampine\n\n\nDifferentialEquations.constructCashKarp\n\n\nDifferentialEquations.constructDormandPrince\n\n\nDifferentialEquations.constructDormandPrince8\n\n\nDifferentialEquations.constructHuen\n\n\nDifferentialEquations.constructRKF\n\n\nDifferentialEquations.constructRKF8\n\n\nDifferentialEquations.constructRalston\n\n\nDifferentialEquations.constructSRA1\n\n\nDifferentialEquations.constructSRIW1\n\n\nDifferentialEquations.conv_ests\n\n\nDifferentialEquations.cubicSDEExample\n\n\nDifferentialEquations.dirichletzeroStokesExample\n\n\nDifferentialEquations.fem_squaremesh\n\n\nDifferentialEquations.findboundary\n\n\nDifferentialEquations.getH1error\n\n\nDifferentialEquations.getL2error\n\n\nDifferentialEquations.getNoise\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n\n\nDifferentialEquations.heatProblemExample_birthdeathinteractingsystem\n\n\nDifferentialEquations.heatProblemExample_birthdeathsystem\n\n\nDifferentialEquations.heatProblemExample_diffuse\n\n\nDifferentialEquations.heatProblemExample_diffusionconstants\n\n\nDifferentialEquations.heatProblemExample_gierermeinhardt\n\n\nDifferentialEquations.heatProblemExample_grayscott\n\n\nDifferentialEquations.heatProblemExample_moving\n\n\nDifferentialEquations.heatProblemExample_pure\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n\n\nDifferentialEquations.homogeneousStokesExample\n\n\nDifferentialEquations.linearODEExample\n\n\nDifferentialEquations.linearSDEExample\n\n\nDifferentialEquations.meshExample_Lshapemesh\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n\n\nDifferentialEquations.meshExample_bunny\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n\n\nDifferentialEquations.meshExample_lakemesh\n\n\nDifferentialEquations.meshExample_oilpump\n\n\nDifferentialEquations.meshExample_wavymesh\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n\n\nDifferentialEquations.monteCarloSim\n\n\nDifferentialEquations.multiDimAdditiveSDEExample\n\n\nDifferentialEquations.notime_squaremesh\n\n\nDifferentialEquations.numparameters\n\n\nDifferentialEquations.parabolic_squaremesh\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n\n\nDifferentialEquations.poissonProblemExample_birthdeathinteractingsystem\n\n\nDifferentialEquations.poissonProblemExample_birthdeathsystem\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n\n\nDifferentialEquations.poissonProblemExample_wave\n\n\nDifferentialEquations.quadfbasis\n\n\nDifferentialEquations.quadpts\n\n\nDifferentialEquations.quadpts1\n\n\nDifferentialEquations.setboundary\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.stokes_prolongation\n\n\nDifferentialEquations.stokes_restriction\n\n\nDifferentialEquations.test_convergence\n\n\nDifferentialEquations.twoDimlinearODEExample\n\n\nDifferentialEquations.twoDimlinearSDEExample\n\n\nDifferentialEquations.update_p!\n\n\nDifferentialEquations.update_u!\n\n\nDifferentialEquations.update_v!\n\n\nDifferentialEquations.uzawa_p!\n\n\nDifferentialEquations.waveSDEExample\n\n\nDifferentialEquations.\u2207basis\n\n\nDifferentialEquations.\u2207u\n\n\nDifferentialEquations.@materialize", 
            "title": "Introduction"
        }, 
        {
            "location": "/#differentialequationsjl-documentation", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes algorithms from very recent research, as well as algorithms optimized for HPC applications. It integrates with the Julia package sphere, for example using Juno's progress meter, and wraps other differential equation solvers so that many different methods for solving the equations can be accessed by simply switching a keyword argument.  All of the algorithms are thoroughly tested to ensure accuracy. Convergence tests are included in the  test/  folder. The algorithms were also tested to show correctness with nontrivial behavior such as Turing morphogenesis. Example IJulia notebooks  can be found in the examples folder . If you find any example where there seems to be an error, please open an issue.  If you have any questions, or just want to chat about solvers/using the package, please feel free to message me in the  Gitter channel . For bug reports, feature requests, etc., please submit an issue. If you're interested in contributing, please see the  Contributor's Guide .", 
            "title": "DifferentialEquations.jl Documentation"
        }, 
        {
            "location": "/#using-the-package", 
            "text": "To install the package, use the following command inside the Julia REPL:  Pkg.add( DifferentialEquations )  For all of the latest features, switch to the master branch via:  Pkg.checkout( DifferentialEquations )  To load the package, use the command:  using DifferentialEquations  To understand the package in more detail, check out the following tutorials in the manual. Examples IJulia notebooks using DifferentialEquations can be found  in the examples folder . Codes for the latest features can be found in  test/ .  For the most up to date on using the package information, please contact me  via the repository Gitter  or  read the latest documentation", 
            "title": "Using the Package"
        }, 
        {
            "location": "/#supported-equations", 
            "text": "For PDEs, one can optionally specify a noise equation. The solvers currently have stochastic variants for handling Gaussian Space-time white noise SPDEs.   ODEs  SODEs   (Stochastic) PDEs   Linear Poisson Equation  Semi-linear Poisson Equation  Linear Heat Equation  Semi-linear Heat Equation (aka Reaction-Diffusion Equation)  Stationary Stokes Equation", 
            "title": "Supported Equations"
        }, 
        {
            "location": "/#implemented-solvers", 
            "text": "For PDEs, [method] denotes an additional version for handling stochastic partial differential equations. SDE solvers and ODE solvers take in general sized inputs. For example, if u\u2080 is a matrix (and your problem functions are designed to work with matrices), then the solver will use the matrices without error.    ODEs    Optimized Explicit Solvers   Euler  Midpoint Method   RK4   General Explicit (Adaptive) Runge-Kutta Methods     Huen's Method   Cash-Karp  Runge-Kutta-Fuhlberg (RKF) 4/5  Ralston's Method  Bogaki-Shampine  Dormand-Prince 4/5  Runge-Kutta-Fuhlberg (RKF) 7/8   Dormand-Prince 7/8   Stiff Solvers. Requires  NLsolve.jl  and optionally  ForwardDiff.jl . See  Conditional Dependencies .     Implicit Euler   Trapezoidal   Rosenbrock32   Wrappers for ODEInterface.jl. See  Conditional Dependencies .     dorpi5 - Hairer's DP5(4)   dop853 - Hairer's DP8(5,3)  odex - Extrapolation algorithm based on explicit midpoint rule  radau5 - Implicit Runge-Kutta order 5  radau - Implicit Runge-Kutta variable order 5-13   seulex - Extrapolation based on linear implicit Euler   Wrappers for ODE.jl. See  Conditional Dependencies .     ode23 - Bogacki-Shampine's method   ode45 - Dormand-Prince  4/5  ode78 - Runge-Kutta-Fuhlberg  7/8  ode23s - Rosenbrock method 2/3  ode1 - Forward Euler  midpoint - Midpoint method  ode2_heun - Huen's method  ode4 - RK4  ode45_fe - Runge-Kutta-Fuhlberg 4/5       SODEs   Euler-Maruyama  Milstein  Rossler-SRK     Finite Element Solvers (Stochastic) PDEs    Semilinear Poisson Equation    See implicit solvers   Semilinear Heat Equation (Reaction-Diffusion)     Forward Euler [Maruyama]   Backward Euler [Maruyama]  Semi-implicit Crank-Nicholson [Maruyama]   Semi-implicit Backward Euler [Maruyama]   Linear Heat Equation     Forward Euler [Maruyama]   Backward Euler [Maruyama]  Crank-Nicholson [Maruyama]       Implicit Solvers   Direct  Factorizations (LU, Cholesky, QR, SVD)  Conjugate-Gradient (CG)  GMRES", 
            "title": "Implemented Solvers"
        }, 
        {
            "location": "/#roadmap", 
            "text": "SODE Solvers   Adaptive-SRK     Finite difference solvers (Stochastic) PDE Solvers   Semi-linear Heat Equation (Reaction-Diffusion Equation)  Semi-linear Poisson Equation  Wave Equation  Transport Equation  Stokes Equation  Implicit Integration Factor (IIF) Maruyama  Implicit Integration Factor (IIF) Milstein", 
            "title": "Roadmap"
        }, 
        {
            "location": "/#ijulia-notebook-tutorials", 
            "text": "If you have  IJulia  installed, you can access extra tutorials in the supplied IJulia notebooks via:  using IJulia\ncd(Pkg.dir( DifferentialEquations )* /examples )\nnotebook()  Otherwise, these notebooks can be viewed  via the Github repository  (note that Github renders them slightly incorrectly, so it will look better in IJulia!).", 
            "title": "IJulia Notebook Tutorials"
        }, 
        {
            "location": "/#tutorials", 
            "text": "The following tutorials will introduce you to the functionality of DifferentialEquations.jl More examples can be found by  checking out the IJulia notebooks in the examples folder .   Ordinary Differential Equation (ODE) Example  Stochastic Differential Equation (SDE) Example  Poisson Equation Finite Element Method Example  Heat Equation Finite Element Method Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#solver-options", 
            "text": "These pages describe the options available in the solvers.   Ordinary Differential Equation Solvers  Pros and Cons of Different Methods    Stochastic Differential Equation Solvers  Finite Element Method Poisson Equation Solvers  Finite Element Method Heat Equation Solvers    Finite Difference Method Stokes Equation Solvers  Stokes Equation", 
            "title": "Solver Options"
        }, 
        {
            "location": "/#manual", 
            "text": "Overview of DifferentialEquations.jl Usage  Extras for Developers and Researchers  Defining an ODE Problem  Problem Type  Example Problems    Defining a SDE Problem  Problem Type  Example Problems    Defining a FEM Problem  Poisson Equation Problem  Heat Equation Problem  Example Problems  Related Functions    Defining a Stokes Problem  Problem Type  Example Problems    Meshes  Mesh Specification  Mesh Type  Mesh Generation Functions  Example Meshes  Plot Functions    The Solution Type  Solution Types  Related Functions    Plot Functions  Standard Plots  Extra Plot Functions    Convergence Simulations  The ConvergenceSimulation Type  Plot Functions  Related Functions    Conditional Dependencies  The Conditional Dependency Notification  What Methods Require Conditional Dependencies?  Installation Instructions", 
            "title": "Manual"
        }, 
        {
            "location": "/#internal-documentation", 
            "text": "Contributor's Guide  Developing New Solver Algorithms  Adding Conditional Dependencies  Developing A New Problem  Other Help    Internal Finite Element Tools  General  Mesh Tools  Solver Tools  Error Tools    Extra Functions  Making Build Work    Solver Helpers  ODE Solver Extras  SDE Solver Extras  Stationary Stokes", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "DifferentialEquations  DifferentialEquations.ODE_DEFAULT_TABLEAU  DifferentialEquations.ConvergenceSimulation  DifferentialEquations.DEProblem  DifferentialEquations.DESolution  DifferentialEquations.ExplicitRK  DifferentialEquations.FEMSolution  DifferentialEquations.FEMmesh  DifferentialEquations.HeatProblem  DifferentialEquations.Mesh  DifferentialEquations.ODEProblem  DifferentialEquations.ODESolution  DifferentialEquations.PoissonProblem  DifferentialEquations.RosslerSRA  DifferentialEquations.RosslerSRI  DifferentialEquations.SDEProblem  DifferentialEquations.SDESolution  DifferentialEquations.SimpleMesh  DifferentialEquations.StokesProblem  DifferentialEquations.StokesSolution  DifferentialEquations.Tableau  Base.length  Base.length  Base.length  Base.size  DifferentialEquations.CFL\u03bc  DifferentialEquations.CFL\u03bd  DifferentialEquations.FEMSolutionTS  DifferentialEquations.GSu!  DifferentialEquations.GSv!  DifferentialEquations.GS\u03b4q!  DifferentialEquations.additiveSDEExample  DifferentialEquations.animate  DifferentialEquations.appxTrue!  DifferentialEquations.assemblematrix  DifferentialEquations.calc_rp!  DifferentialEquations.calc\ud835\udcaaestimates  DifferentialEquations.checkSRAOrder  DifferentialEquations.checkSRIOrder  DifferentialEquations.constructBogakiShampine  DifferentialEquations.constructCashKarp  DifferentialEquations.constructDormandPrince  DifferentialEquations.constructDormandPrince8  DifferentialEquations.constructHuen  DifferentialEquations.constructRKF  DifferentialEquations.constructRKF8  DifferentialEquations.constructRalston  DifferentialEquations.constructSRA1  DifferentialEquations.constructSRIW1  DifferentialEquations.conv_ests  DifferentialEquations.cubicSDEExample  DifferentialEquations.dirichletzeroStokesExample  DifferentialEquations.fem_squaremesh  DifferentialEquations.findboundary  DifferentialEquations.getH1error  DifferentialEquations.getL2error  DifferentialEquations.getNoise  DifferentialEquations.heatProblemExample_birthdeath  DifferentialEquations.heatProblemExample_birthdeathinteractingsystem  DifferentialEquations.heatProblemExample_birthdeathsystem  DifferentialEquations.heatProblemExample_diffuse  DifferentialEquations.heatProblemExample_diffusionconstants  DifferentialEquations.heatProblemExample_gierermeinhardt  DifferentialEquations.heatProblemExample_grayscott  DifferentialEquations.heatProblemExample_moving  DifferentialEquations.heatProblemExample_pure  DifferentialEquations.heatProblemExample_stochasticbirthdeath  DifferentialEquations.homogeneousStokesExample  DifferentialEquations.linearODEExample  DifferentialEquations.linearSDEExample  DifferentialEquations.meshExample_Lshapemesh  DifferentialEquations.meshExample_Lshapeunstructure  DifferentialEquations.meshExample_bunny  DifferentialEquations.meshExample_flowpastcylindermesh  DifferentialEquations.meshExample_lakemesh  DifferentialEquations.meshExample_oilpump  DifferentialEquations.meshExample_wavymesh  DifferentialEquations.meshExample_wavyperturbmesh  DifferentialEquations.monteCarloSim  DifferentialEquations.multiDimAdditiveSDEExample  DifferentialEquations.notime_squaremesh  DifferentialEquations.numparameters  DifferentialEquations.parabolic_squaremesh  DifferentialEquations.poissonProblemExample_birthdeath  DifferentialEquations.poissonProblemExample_birthdeathinteractingsystem  DifferentialEquations.poissonProblemExample_birthdeathsystem  DifferentialEquations.poissonProblemExample_noisyWave  DifferentialEquations.poissonProblemExample_wave  DifferentialEquations.quadfbasis  DifferentialEquations.quadpts  DifferentialEquations.quadpts1  DifferentialEquations.setboundary  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.solve  DifferentialEquations.stokes_prolongation  DifferentialEquations.stokes_restriction  DifferentialEquations.test_convergence  DifferentialEquations.twoDimlinearODEExample  DifferentialEquations.twoDimlinearSDEExample  DifferentialEquations.update_p!  DifferentialEquations.update_u!  DifferentialEquations.update_v!  DifferentialEquations.uzawa_p!  DifferentialEquations.waveSDEExample  DifferentialEquations.\u2207basis  DifferentialEquations.\u2207u  DifferentialEquations.@materialize", 
            "title": "Index"
        }, 
        {
            "location": "/tutorials/ode_example/", 
            "text": "Ordinary Differential Equation (ODE) Example\n\n\nThis tutorial will introduce you to the functionality for solving ODEs. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the equation\n\n\n$$\n\\frac{du}{dt} = f(u,t)\n$$\n\n\nwhere $f(u,t)=\u03b1u$. We know via Calculus that the solution to this equation is $u(t)=u\u2080\\exp(\u03b1t)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:\n\n\nusing DifferentialEquations\n\u03b1=1\nu\u2080=1/2\nf(u,t) = u\nprob = ODEProblem(f,u\u2080)\n\n\n\n\nThen we setup some parameters:\n\n\n\u0394t = 1/2^(4) #The initial step size. It will automatically determined if not given.\ntspan = [0,1] # The timespan. This is the default if not given.\n\n\n\n\nWe then send these items to the solver.\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:Euler)\n\n\n\n\nTo see what's in the solution object, we can print it:\n\n\nprint(sol)\n#DifferentialEquations.ODESolution with 17 timesteps. No analytical solution is known.\n#u: 1.3189642486832998\n#t: [0.0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1.0]\n#timeseries: [0.5,0.53125,0.564453,0.599731,0.637215,0.677041,0.719356,0.764315,0.812085,0.86284,0.916768,0.974066,1.03494,1.09963,1.16836,1.24138,1.31896]\n\n\n\n\nWe can access the 5th value of the solution with\n\n\nsol[5]\n#.637\n\n\n\n\nor get the time of the 8th timestep by\n\n\nsol.t[8]\n#.438\n\n\n\n\nPlotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:\n\n\nplot(sol)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()\n\n\n\n\nThe plot function can be formatted using \nthe attributes available in Plots.jl\n. For more of an introduction to plotting solutions, \nsee the IJulia notebook\n.\n\n\n\n\nOther Algorithms\n\n\nWe can choose a better algorithm by specifying:\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK,adaptive=false)\nplot(sol)\nPlots.gui()\n\n\n\n\n\n\nThe \n\"ExplicitRK\"\n algorithms are general Runge-Kutta solvers. It defaults to Dormand-Prince 4/5, the same solver as MATLAB's \node45\n. Please see the solver documentation for more algorithms.\n\n\nWe can solve the problem in less timesteps by turning on adaptive timestepping. To do so, you simply pass a keyword argument (note: this is true by default):\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:ExplicitRK,adaptive=true)\nplot(sol)\nPlots.gui()\n\n\n\n\n\n\n\n\nSystems of Equations\n\n\nWe can also solve systems of equations. DifferentialEquations.jl can handle any size problem, so instead of showing it for a vector, let's let u be a matrix! To do this, we simply need to have u\u2080 be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:\n\n\nu\u2080=rand(4,2).*ones(4,2)/2\n\u03b1=ones(4,2)\nf(u,t) = \u03b1.*u\nprob = ODEProblem(f,u\u2080)\n\n\n\n\nHere our ODE is on a 4x2 matrix. Since we are using .*, this is 8 independent ODEs, but you can do whatever you want. To solve the ODE, we do the same steps as before.\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK)\nplot(sol)\nPlots.gui()", 
            "title": "Ordinary Differential Equation Example"
        }, 
        {
            "location": "/tutorials/ode_example/#ordinary-differential-equation-ode-example", 
            "text": "This tutorial will introduce you to the functionality for solving ODEs. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the equation  $$\n\\frac{du}{dt} = f(u,t)\n$$  where $f(u,t)=\u03b1u$. We know via Calculus that the solution to this equation is $u(t)=u\u2080\\exp(\u03b1t)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:  using DifferentialEquations\n\u03b1=1\nu\u2080=1/2\nf(u,t) = u\nprob = ODEProblem(f,u\u2080)  Then we setup some parameters:  \u0394t = 1/2^(4) #The initial step size. It will automatically determined if not given.\ntspan = [0,1] # The timespan. This is the default if not given.  We then send these items to the solver.  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:Euler)  To see what's in the solution object, we can print it:  print(sol)\n#DifferentialEquations.ODESolution with 17 timesteps. No analytical solution is known.\n#u: 1.3189642486832998\n#t: [0.0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1.0]\n#timeseries: [0.5,0.53125,0.564453,0.599731,0.637215,0.677041,0.719356,0.764315,0.812085,0.86284,0.916768,0.974066,1.03494,1.09963,1.16836,1.24138,1.31896]  We can access the 5th value of the solution with  sol[5]\n#.637  or get the time of the 8th timestep by  sol.t[8]\n#.438  Plotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:  plot(sol)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()  The plot function can be formatted using  the attributes available in Plots.jl . For more of an introduction to plotting solutions,  see the IJulia notebook .", 
            "title": "Ordinary Differential Equation (ODE) Example"
        }, 
        {
            "location": "/tutorials/ode_example/#other-algorithms", 
            "text": "We can choose a better algorithm by specifying:  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK,adaptive=false)\nplot(sol)\nPlots.gui()   The  \"ExplicitRK\"  algorithms are general Runge-Kutta solvers. It defaults to Dormand-Prince 4/5, the same solver as MATLAB's  ode45 . Please see the solver documentation for more algorithms.  We can solve the problem in less timesteps by turning on adaptive timestepping. To do so, you simply pass a keyword argument (note: this is true by default):  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,alg=:ExplicitRK,adaptive=true)\nplot(sol)\nPlots.gui()", 
            "title": "Other Algorithms"
        }, 
        {
            "location": "/tutorials/ode_example/#systems-of-equations", 
            "text": "We can also solve systems of equations. DifferentialEquations.jl can handle any size problem, so instead of showing it for a vector, let's let u be a matrix! To do this, we simply need to have u\u2080 be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:  u\u2080=rand(4,2).*ones(4,2)/2\n\u03b1=ones(4,2)\nf(u,t) = \u03b1.*u\nprob = ODEProblem(f,u\u2080)  Here our ODE is on a 4x2 matrix. Since we are using .*, this is 8 independent ODEs, but you can do whatever you want. To solve the ODE, we do the same steps as before.  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,save_timeseries=true,alg=:ExplicitRK)\nplot(sol)\nPlots.gui()", 
            "title": "Systems of Equations"
        }, 
        {
            "location": "/tutorials/sde_example/", 
            "text": "Stochastic Differential Equation (SDE) Example\n\n\nThis tutorial will introduce you to the functionality for solving SDE. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the equation\n\n\n$$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$\n\n\nwhere $f(u,t)=\u03b1u$ and $\u03c3(u,t)=\u03b2u$. We know via Stochastic Calculus that the solution to this equation is $u(t,W)=u\u2080\nexp((\u03b1-(\u03b2^2)/2)\nt+\u03b2*W)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:\n\n\nusing DifferentialEquations\n\u03b1=1\n\u03b2=1\nu\u2080=1/2\nf(u,t) = \u03b1*u\n\u03c3(u,t) = \u03b2*u\n\u0394t = 1//2^(4) #The initial timestepping size. It will automatically assigned if not given.\ntspan = [0,1] # The timespan. This is the default if not given.\n\n\n\n\nFor reference, let's also give the \nSDEProblem\n the analytical solution. Note that each of the problem types allow for this, but it's always optional. This can be a good way to judge how accurate the algorithms are, or is used to test convergence of the algorithms for methods developers. Thus we define the problem object with:\n\n\nanalytic(u\u2080,t,W) = u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\nprob = SDEProblem(f,\u03c3,u\u2080,analytic=analytic)\n\n\n\n\nand then we pass this information to the solver and plot:\n\n\n#We can plot using the classic Euler-Maruyama algorithm as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:EM)\nplot(sol,plot_analytic=true)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()\n\n\n\n\n\n\nWe can choose a higher-order solver for a more accurate result:\n\n\n#We can choose a better method as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:SRIW1Optimized)\nplot(sol,plot_analytic=true)\nPlots.gui()", 
            "title": "Stochastic Differential Equation Example"
        }, 
        {
            "location": "/tutorials/sde_example/#stochastic-differential-equation-sde-example", 
            "text": "This tutorial will introduce you to the functionality for solving SDE. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the equation  $$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$  where $f(u,t)=\u03b1u$ and $\u03c3(u,t)=\u03b2u$. We know via Stochastic Calculus that the solution to this equation is $u(t,W)=u\u2080 exp((\u03b1-(\u03b2^2)/2) t+\u03b2*W)$. To solve this numerically, we define a problem type by giving it the equation and the initial condition:  using DifferentialEquations\n\u03b1=1\n\u03b2=1\nu\u2080=1/2\nf(u,t) = \u03b1*u\n\u03c3(u,t) = \u03b2*u\n\u0394t = 1//2^(4) #The initial timestepping size. It will automatically assigned if not given.\ntspan = [0,1] # The timespan. This is the default if not given.  For reference, let's also give the  SDEProblem  the analytical solution. Note that each of the problem types allow for this, but it's always optional. This can be a good way to judge how accurate the algorithms are, or is used to test convergence of the algorithms for methods developers. Thus we define the problem object with:  analytic(u\u2080,t,W) = u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\nprob = SDEProblem(f,\u03c3,u\u2080,analytic=analytic)  and then we pass this information to the solver and plot:  #We can plot using the classic Euler-Maruyama algorithm as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:EM)\nplot(sol,plot_analytic=true)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()   We can choose a higher-order solver for a more accurate result:  #We can choose a better method as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,alg=:SRIW1Optimized)\nplot(sol,plot_analytic=true)\nPlots.gui()", 
            "title": "Stochastic Differential Equation (SDE) Example"
        }, 
        {
            "location": "/tutorials/fempoisson_example/", 
            "text": "Poisson Equation Finite Element Method Example\n\n\nThis tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the Poisson Equation $\u0394u=f$. For our example, we will take the linear equation where $f(x,y) = \\sin(2\u03c0x)\\cos(2\u03c0y)$. For this equation we know that solution is $u(x,y,t)= \\sin(2\u03c0x)\\cos(2\u03c0y)/(8\u03c0^2)$ with gradient $Du(x,y) = [\\cos(2\u03c0x)\\cos(2\u03c0y)/(4\u03c0) -\\sin(2\u03c0x)\\sin(2\u03c0y)/(4\u03c0)]$. Thus, we define a PoissonProblem as follows:\n\n\nf(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\ngD(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\nprob = PoissonProblem(f,gD)\n\n\n\n\nHere we chose the dirichlet boundary condition \ngD\n to give the theoretical solution.  Other example problems can be found in \nsrc/examples/exampleProblems.jl\n. To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:\n\n\n\u0394x = 1//2^(5)\nfem_mesh = notime_squaremesh([0 1 0 1],\u0394x,:dirichlet)\n\n\n\n\nNote that by specifying :dirichlet our boundary conditions is set on all boundaries to dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as \niFEM\n. Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use\n\n\nsol = solve(fem_mesh,pdeProb)\n\n\n\n\nfem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This returns a FEMSolution object which holds data about the solution, such as the solution values (u). To plot the solution, we use the command\n\n\nplot(sol::FEMSolution)\nPlots.gui()\n\n\n\n\nHere is the plot shown against the analytical solution to show the accuracy:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/fempoisson_example/#poisson-equation-finite-element-method-example", 
            "text": "This tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the Poisson Equation $\u0394u=f$. For our example, we will take the linear equation where $f(x,y) = \\sin(2\u03c0x)\\cos(2\u03c0y)$. For this equation we know that solution is $u(x,y,t)= \\sin(2\u03c0x)\\cos(2\u03c0y)/(8\u03c0^2)$ with gradient $Du(x,y) = [\\cos(2\u03c0x)\\cos(2\u03c0y)/(4\u03c0) -\\sin(2\u03c0x)\\sin(2\u03c0y)/(4\u03c0)]$. Thus, we define a PoissonProblem as follows:  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\ngD(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\nprob = PoissonProblem(f,gD)  Here we chose the dirichlet boundary condition  gD  to give the theoretical solution.  Other example problems can be found in  src/examples/exampleProblems.jl . To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:  \u0394x = 1//2^(5)\nfem_mesh = notime_squaremesh([0 1 0 1],\u0394x,:dirichlet)  Note that by specifying :dirichlet our boundary conditions is set on all boundaries to dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as  iFEM . Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use  sol = solve(fem_mesh,pdeProb)  fem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This returns a FEMSolution object which holds data about the solution, such as the solution values (u). To plot the solution, we use the command  plot(sol::FEMSolution)\nPlots.gui()  Here is the plot shown against the analytical solution to show the accuracy:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femheat_example/", 
            "text": "Heat Equation Finite Element Method Example\n\n\nThis tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nIn this example we will solve the heat equation $u_t=\u0394u+f$. To do this, we define a HeatProblem which contains the function $f$ and the boundary conditions. We specify one as follows:\n\n\nf(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\nprob = HeatProblem(u\u2080,f)\n\n\n\n\nHere the equation we chose was nonlinear since $f$ depends on the variable $u$. Thus we specify f=f(u,x,t). If $f$ did not depend on u, then we would specify f=f(x,t). We do need to specify $gD$ (the dirichlet boundary condition) and $gN$ (the neumann boundary condition) since both are zero. $u0$ specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.\n\n\nWe then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command\n\n\nT = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)\n\n\n\n\nWe then call the solver\n\n\nsol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler)\n\n\n\n\nHere we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femheat_example/#heat-equation-finite-element-method-example", 
            "text": "This tutorial will introduce you to the functionality for solving a PDE. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  In this example we will solve the heat equation $u_t=\u0394u+f$. To do this, we define a HeatProblem which contains the function $f$ and the boundary conditions. We specify one as follows:  f(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\nprob = HeatProblem(u\u2080,f)  Here the equation we chose was nonlinear since $f$ depends on the variable $u$. Thus we specify f=f(u,x,t). If $f$ did not depend on u, then we would specify f=f(x,t). We do need to specify $gD$ (the dirichlet boundary condition) and $gN$ (the neumann boundary condition) since both are zero. $u0$ specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.  We then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command  T = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)  We then call the solver  sol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler)  Here we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femstochastic_example/", 
            "text": "Stochastic Finite Element Examples\n\n\nThis tutorial will introduce you to the functionality for solving SPDEs. Other introductions can be found by \nchecking out the IJulia notebooks in the examples folder\n.\n\n\nFor most PDE problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments $dW$, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noisetype which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.\n\n\nThe following examples show how to change the tutorial problems into stochastic problems.\n\n\n\n\nFinite Element Stochastic Poisson Equation\n\n\nWe can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  $-\u0394u=f+gdW$, with additive space-time white noise by specifying the problem as:\n\n\nf(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n\u03c3(x) = 5 #Additive noise\nprob = PoissonProblem(f,\u03c3=\u03c3)\n\n\n\n\nThis gives the following plot:\n\n\n\n\n\n\nFinite Element Stochastic Heat Equation\n\n\nThis will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function \nf(u)=.5-u\n, noise function \ng(u)=100u^2\n and initial condition \nu0=0\n. We would expect this system to rise towards the deterministic steady state \nu=2\n (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:\n\n\nf(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\n\u03c3(u,x,t) = 1u.^2\nprob = HeatProblem(u\u2080,f,\u03c3=\u03c3)\n\n\n\n\nWe use the following code create an animation of the solution:\n\n\nT = 5\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(11)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)\n\nsol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler,save_timeseries=true,solver=:LU)\nanimate(sol::FEMSolution;zlim=(0,3),cbar=false)", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femstochastic_example/#stochastic-finite-element-examples", 
            "text": "This tutorial will introduce you to the functionality for solving SPDEs. Other introductions can be found by  checking out the IJulia notebooks in the examples folder .  For most PDE problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments $dW$, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noisetype which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.  The following examples show how to change the tutorial problems into stochastic problems.", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femstochastic_example/#finite-element-stochastic-poisson-equation", 
            "text": "We can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  $-\u0394u=f+gdW$, with additive space-time white noise by specifying the problem as:  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n\u03c3(x) = 5 #Additive noise\nprob = PoissonProblem(f,\u03c3=\u03c3)  This gives the following plot:", 
            "title": "Finite Element Stochastic Poisson Equation"
        }, 
        {
            "location": "/tutorials/femstochastic_example/#finite-element-stochastic-heat-equation", 
            "text": "This will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function  f(u)=.5-u , noise function  g(u)=100u^2  and initial condition  u0=0 . We would expect this system to rise towards the deterministic steady state  u=2  (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:  f(u,x,t)  = ones(size(x,1)) - .5u\nu\u2080(x) = zeros(size(x,1))\n\u03c3(u,x,t) = 1u.^2\nprob = HeatProblem(u\u2080,f,\u03c3=\u03c3)  We use the following code create an animation of the solution:  T = 5\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(11)\nfem_mesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,:neumann)\n\nsol = solve(fem_mesh::FEMmesh,prob::HeatProblem,alg=:Euler,save_timeseries=true,solver=:LU)\nanimate(sol::FEMSolution;zlim=(0,3),cbar=false)", 
            "title": "Finite Element Stochastic Heat Equation"
        }, 
        {
            "location": "/solvers/ode_solve/", 
            "text": "Ordinary Differential Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nsolve(prob::ODEProblem,tspan)\n\n\nSolves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].\n\n\nKeyword Arguments\n\n\n\n\n\u0394t\n: Sets the initial stepsize. Defaults to an automatic choice.\n\n\nsave_timeseries\n: Saves the result at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes how many steps between saving a value for the timeseries. Defaults to 1.\n\n\ntableau\n: The tableau for an \n:ExplicitRK\n algorithm. Defaults to a Dormand-Prince 4/5 method.\n\n\nadaptive\n - Turns on adaptive timestepping for appropriate methods. Default is true.\n\n\n\u03b3\n - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.\n\n\nqmax\n - Defines the maximum value possible for the adaptive q. Default is 10.\n\n\nablstol\n - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.\n\n\nreltol\n - Relative tolerance in adaptive timestepping. Defaults to 1e-6.\n\n\nmaxiters\n - Maximum number of iterations before stopping. Defaults to 1e9.\n\n\n\u0394tmax\n - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.\n\n\n\u0394tmin\n - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.\n\n\nautodiff\n - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use \nNLsolve\n. Default is true.\n\n\ninternalnorm\n - The norm for which error estimates are calculated. Default is 2.\n\n\nprogressbar\n - Turns on/off the Juno progressbar. Defualt is false.\n\n\nprogress_steps\n - Numbers of steps between updates of the progress bar. Default is 1000.\n\n\n\n\nalg\n: String which defines the solver algorithm. Defult is \n:ExplicitRK\n. Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify \nSSBETA=0.03\n as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as \nMAXSS\n (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax \n\u0394tmax\n or \nMAXSS\n. The possibilities for the solvers are:\n\n\n\n\n\n\nDifferentialEquations.jl\n\n\n\n\n:Euler\n- The canonical forward Euler method.\n\n\n:Midpoint\n - The second order midpoint method.\n\n\n:RK4\n - The canonical Runge-Kutta Order 4 method.\n\n\n\n\n:ExplicitRK\n - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument \ntab=tableau\n. The default tableau is for Dormand-Prine 4/5. Other supplied tableaus include:\n\n\n\n\nconstructRalston()\n - Returns a tableau for Ralston's method\n\n\nconstructRKF()\n - Returns a tableau for Runge-Kutta-Fuhlberg 4/5\n\n\nconstructBogakiShampine()\n - Returns a tableau for Bogakai-Shampine's 2/3 method.\n\n\nconstructCashKarp()\n - Returns a tableau for the Cash-Karp method 4/5.\n\n\nconstructDormandPrince()\n - Returns a tableau for Dormand-Prince 4/5.\n\n\nconstructRKF8()\n - Returns a tableau for Runge-Kutta-Fuhlberg Order 7/8 method.\n\n\nconstructDormandPrice8()\n - Returns a tableau for the Dormand-Prince Order 7/8 method.\n          * \n:ImplicitEuler\n - A 1st order implicit solver. Unconditionally stable.\n          * \n:Trapezoid\n - A second order unconditionally stable implicit solver. Good for highly stiff.\n          * \n:Rosenbrock32\n - A fast solver which is good for stiff equations.\n\n\nODEInterface.jl\n\n\n\n\n\n\n\n\n\n\n\n\n:dopri5\n - Hairer's classic implementation of the Dormand-Prince 4/5 method.\n\n\n\n\n:dop853\n - Explicit Runge-Kutta 8(5,3) by Dormand-Prince\n\n\n:odex\n - GBS extrapolation-algorithm based on the midpoint rule\n\n\n:seulex\n - extrapolation-algorithm bsed on the linear implicit Euler method\n\n\n:radau\n - implicit Runge-Kutta (Rdau IIA) of variable order between 5 and 13\n\n\n\n\n:radau5\n - implicit Runge-Kutta method (Radau IIA) of order 5\n\n\n\n\nODE.jl\n\n\n\n\n\n\n\n\n:ode23\n - Bogakai-Shampine's 2/3 method\n\n\n\n\n:ode45\n - Dormand-Prince's 4/5 method\n\n\n:ode78\n - Runge-Kutta-Fuhlberg 7/8 method\n\n\n:ode23s\n - Rosenbrock's 2/3 method\n\n\n:ode1\n - Forward Euler\n\n\n:ode2_midpoint\n - Midpoint Method\n\n\n:ode2_heun\n - Heun's Method\n\n\n:ode4\n - RK4\n\n\n:ode45_fe\n - Runge-Kutta-Fuhlberg 4/5 method\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\nPros and Cons of Different Methods", 
            "title": "Ordinary Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/ode_solve/#ordinary-differential-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  solve(prob::ODEProblem,tspan)  Solves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].  Keyword Arguments   \u0394t : Sets the initial stepsize. Defaults to an automatic choice.  save_timeseries : Saves the result at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes how many steps between saving a value for the timeseries. Defaults to 1.  tableau : The tableau for an  :ExplicitRK  algorithm. Defaults to a Dormand-Prince 4/5 method.  adaptive  - Turns on adaptive timestepping for appropriate methods. Default is true.  \u03b3  - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.  qmax  - Defines the maximum value possible for the adaptive q. Default is 10.  ablstol  - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.  reltol  - Relative tolerance in adaptive timestepping. Defaults to 1e-6.  maxiters  - Maximum number of iterations before stopping. Defaults to 1e9.  \u0394tmax  - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.  \u0394tmin  - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.  autodiff  - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use  NLsolve . Default is true.  internalnorm  - The norm for which error estimates are calculated. Default is 2.  progressbar  - Turns on/off the Juno progressbar. Defualt is false.  progress_steps  - Numbers of steps between updates of the progress bar. Default is 1000.   alg : String which defines the solver algorithm. Defult is  :ExplicitRK . Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify  SSBETA=0.03  as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as  MAXSS  (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax  \u0394tmax  or  MAXSS . The possibilities for the solvers are:    DifferentialEquations.jl   :Euler - The canonical forward Euler method.  :Midpoint  - The second order midpoint method.  :RK4  - The canonical Runge-Kutta Order 4 method.   :ExplicitRK  - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument  tab=tableau . The default tableau is for Dormand-Prine 4/5. Other supplied tableaus include:   constructRalston()  - Returns a tableau for Ralston's method  constructRKF()  - Returns a tableau for Runge-Kutta-Fuhlberg 4/5  constructBogakiShampine()  - Returns a tableau for Bogakai-Shampine's 2/3 method.  constructCashKarp()  - Returns a tableau for the Cash-Karp method 4/5.  constructDormandPrince()  - Returns a tableau for Dormand-Prince 4/5.  constructRKF8()  - Returns a tableau for Runge-Kutta-Fuhlberg Order 7/8 method.  constructDormandPrice8()  - Returns a tableau for the Dormand-Prince Order 7/8 method.\n          *  :ImplicitEuler  - A 1st order implicit solver. Unconditionally stable.\n          *  :Trapezoid  - A second order unconditionally stable implicit solver. Good for highly stiff.\n          *  :Rosenbrock32  - A fast solver which is good for stiff equations.  ODEInterface.jl       :dopri5  - Hairer's classic implementation of the Dormand-Prince 4/5 method.   :dop853  - Explicit Runge-Kutta 8(5,3) by Dormand-Prince  :odex  - GBS extrapolation-algorithm based on the midpoint rule  :seulex  - extrapolation-algorithm bsed on the linear implicit Euler method  :radau  - implicit Runge-Kutta (Rdau IIA) of variable order between 5 and 13   :radau5  - implicit Runge-Kutta method (Radau IIA) of order 5   ODE.jl     :ode23  - Bogakai-Shampine's 2/3 method   :ode45  - Dormand-Prince's 4/5 method  :ode78  - Runge-Kutta-Fuhlberg 7/8 method  :ode23s  - Rosenbrock's 2/3 method  :ode1  - Forward Euler  :ode2_midpoint  - Midpoint Method  :ode2_heun  - Heun's Method  :ode4  - RK4  :ode45_fe  - Runge-Kutta-Fuhlberg 4/5 method       source", 
            "title": "Ordinary Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/ode_solve/#pros-and-cons-of-different-methods", 
            "text": "", 
            "title": "Pros and Cons of Different Methods"
        }, 
        {
            "location": "/solvers/sde_solve/", 
            "text": "Stochastic Differential Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\n`solve(prob::SDEProblem,tspan)``\n\n\nSolves the SDE as defined by prob on the time interval tspan. If not given, tspan defaults to [0,1].\n\n\nKeyword Arguments\n\n\n\n\n\u0394t\n: Sets the initial stepsize. Defaults to an automatic choice.\n\n\nsave_timeseries\n: Saves the result at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes how many steps between saving a value for the timeseries. Defaults to 1.\n\n\nadaptive\n - Turns on adaptive timestepping for appropriate methods. Default is false.\n\n\n\u03b3\n - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.\n\n\nqmax\n - Defines the maximum value possible for the adaptive q. Default is 1.125.\n\n\n\u03b4\n - The weight-factor in the error estimate. Default is 1/6.\n\n\nablstol\n - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.\n\n\nreltol\n - Relative tolerance in adaptive timestepping. Defaults to 1e-6.\n\n\nmaxiters\n - Maximum number of iterations before stopping. Defaults to 1e9.\n\n\n\u0394tmax\n - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.\n\n\n\u0394tmin\n - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.\n\n\ninternalnorm\n - The norm for which error estimates are calculated. Default is 2.\n\n\nprogressbar\n - Turns on/off the Juno progressbar. Defualt is false.\n\n\nprogress_steps\n - Numbers of steps between updates of the progress bar. Default is 1000.\n\n\ndiscard_length\n - Size at which to discard future information in adaptive. Default is 1e-15.\n\n\ntableau\n: The tableau for an \n:SRA\n or \n:SRI\n algorithm. Defaults to SRIW1 or SRA1.\n\n\nadaptivealg\n: The adaptive timestepping algorithm. Default is \n:RSwm3\n.\n\n\n\n\nalg\n: String which defines the solver algorithm. Defult is \"SRIW1Optimized\". Possibilities are:\n\n\n\n\n:EM\n- The Euler-Maruyama method.\n\n\n:RKMil\n - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.\n\n\n:SRA\n - The strong Order 2.0 methods for additive SDEs due to Rossler. Not yet implemented.   Default tableau is for SRA1.\n\n\n:SRI\n - The strong Order 1.5 methods for diagonal/scalar SDEs due to Rossler. Default tableau is for SRIW1.\n\n\n:SRIW1Optimized\n - An optimized version of SRIW1. Strong Order 1.5.\n\n\n:SRA1Optimized\n - An optimized version of SRIA1. Strong Order 2.0.\n\n\n:SRAVectorized\n - A vectorized implementation of SRA algorithms. Requires 1-dimensional problem.\n\n\n:SRIVectorized\n - A vectorized implementation of SRI algorithms. Requires 1-dimensional problem.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Stochastic Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/sde_solve/#stochastic-differential-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  `solve(prob::SDEProblem,tspan)``  Solves the SDE as defined by prob on the time interval tspan. If not given, tspan defaults to [0,1].  Keyword Arguments   \u0394t : Sets the initial stepsize. Defaults to an automatic choice.  save_timeseries : Saves the result at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes how many steps between saving a value for the timeseries. Defaults to 1.  adaptive  - Turns on adaptive timestepping for appropriate methods. Default is false.  \u03b3  - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.  qmax  - Defines the maximum value possible for the adaptive q. Default is 1.125.  \u03b4  - The weight-factor in the error estimate. Default is 1/6.  ablstol  - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.  reltol  - Relative tolerance in adaptive timestepping. Defaults to 1e-6.  maxiters  - Maximum number of iterations before stopping. Defaults to 1e9.  \u0394tmax  - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.  \u0394tmin  - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.  internalnorm  - The norm for which error estimates are calculated. Default is 2.  progressbar  - Turns on/off the Juno progressbar. Defualt is false.  progress_steps  - Numbers of steps between updates of the progress bar. Default is 1000.  discard_length  - Size at which to discard future information in adaptive. Default is 1e-15.  tableau : The tableau for an  :SRA  or  :SRI  algorithm. Defaults to SRIW1 or SRA1.  adaptivealg : The adaptive timestepping algorithm. Default is  :RSwm3 .   alg : String which defines the solver algorithm. Defult is \"SRIW1Optimized\". Possibilities are:   :EM - The Euler-Maruyama method.  :RKMil  - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.  :SRA  - The strong Order 2.0 methods for additive SDEs due to Rossler. Not yet implemented.   Default tableau is for SRA1.  :SRI  - The strong Order 1.5 methods for diagonal/scalar SDEs due to Rossler. Default tableau is for SRIW1.  :SRIW1Optimized  - An optimized version of SRIW1. Strong Order 1.5.  :SRA1Optimized  - An optimized version of SRIA1. Strong Order 2.0.  :SRAVectorized  - A vectorized implementation of SRA algorithms. Requires 1-dimensional problem.  :SRIVectorized  - A vectorized implementation of SRI algorithms. Requires 1-dimensional problem.     source", 
            "title": "Stochastic Differential Equation Solvers"
        }, 
        {
            "location": "/solvers/fempoisson_solve/", 
            "text": "Finite Element Method Poisson Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nFinite Element Poisson Equation Solver\n\n\nsolve(fem_mesh::FEMmesh,pdeProb::PoissonProblem)\n\n\nTakes in a definition for the heat equation $-\u0394u = f$ on \nfem_mesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic Poisson equation $-\u0394u = f + \u03c3dW$.\n\n\nKeyword Arguments\n\n\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\n\n\n:Direct\n = Solves \nAx=b\n using \n\\\n\n\n:CG\n = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.\n\n\n:GMRES\n = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.\n\n\ntimeseries_steps\n = If \nsave_timeseries=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Poisson Equation Finite Element Method Solvers"
        }, 
        {
            "location": "/solvers/fempoisson_solve/#finite-element-method-poisson-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  Finite Element Poisson Equation Solver  solve(fem_mesh::FEMmesh,pdeProb::PoissonProblem)  Takes in a definition for the heat equation $-\u0394u = f$ on  fem_mesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic Poisson equation $-\u0394u = f + \u03c3dW$.  Keyword Arguments    solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:   :Direct  = Solves  Ax=b  using  \\  :CG  = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.  :GMRES  = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.  timeseries_steps  = If  save_timeseries=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.     source", 
            "title": "Finite Element Method Poisson Equation Solvers"
        }, 
        {
            "location": "/solvers/femheat_solve/", 
            "text": "Finite Element Method Heat Equation Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nFinite Element Heat Equation Solver\n\n\nsolve(fem_mesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation $u_t = \u0394u + f$ on \nfem_mesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic heat equation $u_t = \u0394u + f + \u03c3dW_t$.\n\n\nKeyword Arguments\n\n\n\n\n\n\nalg\n = Solution algorithm. Default is :Euler. The choices are:\n\n\n\n\n\n\nLinear\n\n\n\n\n:Euler\n (Explicit)\n\n\n:ImplicitEuler\n (Implicit)\n\n\n\n\n:CrankNicholson\n (Implicit)\n\n\n\n\nNonlinear\n\n\n\n\n\n\n\n\n:Euler\n (Explicit)\n\n\n\n\n:ImplicitEuler\n (Nonlinear Solve)\n\n\n:CrankNicholson\n (Nonlinear Solve)\n\n\n:SemiImplicitEuler\n (Implicit)\n\n\n:SemiImplicitCrankNicholson\n (Implicit)\n\n\n\n\n\n\n\n\n\n\n\n\nExplicit algorithms only require solving matrix multiplications \nAu\n. Implicit algorithms require solving the linear equation \nAx=b\n where \nx\n is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).\n\n\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\n\n\n:Direct\n = Solves using \n\\\n (no factorization). Not recommended.\n\n\n:Cholesky\n = Cholsky decomposition. Only stable of $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite. This means that this works best when \u0394t is small. When applicable, this is the fastest.\n\n\n:LU\n = LU-Decomposition. A good mix between fast and stable.\n\n\n:QR\n = QR-Decomposition. Less numerical roundoff error than \nLU\n, but slightly slower.\n\n\n:SVD\n = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.\n\n\n:CG\n = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.\n\n\n:GMRES\n = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.\n\n\nsave_timeseries\n = Makes the algorithm save the output at every \ntimeseries_steps\n timesteps. By default save_timeseries is false.\n\n\ntimeseries_steps\n = If \nsave_timeseries=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\nprogress_steps\n = The number of steps between updates of the progress bar. Defaults to 1000.\n\n\nprogressbar\n = Turns on/off use of the Juno progress bar. Defaults to true. Requires Juno.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Heat Equation Finite Element Method Solvers"
        }, 
        {
            "location": "/solvers/femheat_solve/#finite-element-method-heat-equation-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  Finite Element Heat Equation Solver  solve(fem_mesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation $u_t = \u0394u + f$ on  fem_mesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic heat equation $u_t = \u0394u + f + \u03c3dW_t$.  Keyword Arguments    alg  = Solution algorithm. Default is :Euler. The choices are:    Linear   :Euler  (Explicit)  :ImplicitEuler  (Implicit)   :CrankNicholson  (Implicit)   Nonlinear     :Euler  (Explicit)   :ImplicitEuler  (Nonlinear Solve)  :CrankNicholson  (Nonlinear Solve)  :SemiImplicitEuler  (Implicit)  :SemiImplicitCrankNicholson  (Implicit)       Explicit algorithms only require solving matrix multiplications  Au . Implicit algorithms require solving the linear equation  Ax=b  where  x  is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).    solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:   :Direct  = Solves using  \\  (no factorization). Not recommended.  :Cholesky  = Cholsky decomposition. Only stable of $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite. This means that this works best when \u0394t is small. When applicable, this is the fastest.  :LU  = LU-Decomposition. A good mix between fast and stable.  :QR  = QR-Decomposition. Less numerical roundoff error than  LU , but slightly slower.  :SVD  = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.  :CG  = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.  :GMRES  = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.  save_timeseries  = Makes the algorithm save the output at every  timeseries_steps  timesteps. By default save_timeseries is false.  timeseries_steps  = If  save_timeseries=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.  progress_steps  = The number of steps between updates of the progress bar. Defaults to 1000.  progressbar  = Turns on/off use of the Juno progress bar. Defaults to true. Requires Juno.     source", 
            "title": "Finite Element Method Heat Equation Solvers"
        }, 
        {
            "location": "/solvers/fdmstokes_solve/", 
            "text": "Finite Difference Method Stokes Equation Solvers\n\n\n\n\nStokes Equation\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nsolve(prob::StokesProblem,mesh::FDMMesh)\n\n\nSolves the given stationary Stokes problem on the given finite difference mesh.\n\n\nKeyword Arguments\n\n\n\n\nconverrors\n: Whether to calculate all of the errors along the convergence. Default is true.\n\n\nmaxiters\n: Maximum number of iterations before haulting. Default is 100.\n\n\nalg\n: The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".\n\n\nlevel\n: The number of levels in the Multigrid. Default is 2.\n\n\nsmoothSteps\n: The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.\n\n\ncoarseSteps\n: The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.\n\n\ngsiters\n: The number of Gauss-Seidel iterations to do at each step. Default is 20.\n\n\n\n\nsource", 
            "title": "Stationary Stokes Equation Finite Difference Method Solvers"
        }, 
        {
            "location": "/solvers/fdmstokes_solve/#finite-difference-method-stokes-equation-solvers", 
            "text": "", 
            "title": "Finite Difference Method Stokes Equation Solvers"
        }, 
        {
            "location": "/solvers/fdmstokes_solve/#stokes-equation", 
            "text": "#  DifferentialEquations.solve     Method .  solve(prob::StokesProblem,mesh::FDMMesh)  Solves the given stationary Stokes problem on the given finite difference mesh.  Keyword Arguments   converrors : Whether to calculate all of the errors along the convergence. Default is true.  maxiters : Maximum number of iterations before haulting. Default is 100.  alg : The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".  level : The number of levels in the Multigrid. Default is 2.  smoothSteps : The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.  coarseSteps : The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.  gsiters : The number of Gauss-Seidel iterations to do at each step. Default is 20.   source", 
            "title": "Stokes Equation"
        }, 
        {
            "location": "/man/overview/", 
            "text": "Overview of DifferentialEquations.jl Usage\n\n\nThe general workflow for using the package is as follows:\n\n\n\n\nDefine a problem\n\n\nGenerate a mesh\n\n\nUse a solver on the problem and mesh\n\n\nAnalyze the output\n\n\n\n\nProblems are specified via a type interface. For example, for the Poisson equation $\u0394u = f$, one defines a type which holds \nf\n and the boundary condition functions.\n\n\nNext, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. $[0,1]^2 \\times [0,T]$, then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.\n\n\nOne then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.\n\n\nWith the solution object, you do the analysis as you please! For some result \nsol\n, the field \nsol.u\n returns the final solution, and if you give a true solution, \nsol.u_analytic\n is the true solution at the final time. If you specified to the solver \nsave_timeseries=true\n, then \nsol.timeseries\n and \nsol.ts\n will be outputted which hold the solution/time at every \ntimeseries_steps\n (default set to 100, meaning it saves an output every 100 steps).\n\n\nPlotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the \nplot(type)\n and the plotter will generate appropriate plots. If \nsave_timeseries\n was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.\n\n\n\n\nExtras for Developers and Researchers\n\n\nDifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. The problem types allow one to optionally specify the true solution. When this is given to the solver, the solution object returns with many error calculations. An array of solutions can be made into a \nConvergenceSimulation\n (or the test_convergence functions can be used) which then generates all of the convergence test results and allows for plotting (great for developing new methods!). Lastly, \nBenchmarkSimulations\n allows one to compare between methods and easily plot the results.", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#overview-of-differentialequationsjl-usage", 
            "text": "The general workflow for using the package is as follows:   Define a problem  Generate a mesh  Use a solver on the problem and mesh  Analyze the output   Problems are specified via a type interface. For example, for the Poisson equation $\u0394u = f$, one defines a type which holds  f  and the boundary condition functions.  Next, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. $[0,1]^2 \\times [0,T]$, then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.  One then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.  With the solution object, you do the analysis as you please! For some result  sol , the field  sol.u  returns the final solution, and if you give a true solution,  sol.u_analytic  is the true solution at the final time. If you specified to the solver  save_timeseries=true , then  sol.timeseries  and  sol.ts  will be outputted which hold the solution/time at every  timeseries_steps  (default set to 100, meaning it saves an output every 100 steps).  Plotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the  plot(type)  and the plotter will generate appropriate plots. If  save_timeseries  was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#extras-for-developers-and-researchers", 
            "text": "DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. The problem types allow one to optionally specify the true solution. When this is given to the solver, the solution object returns with many error calculations. An array of solutions can be made into a  ConvergenceSimulation  (or the test_convergence functions can be used) which then generates all of the convergence test results and allows for plotting (great for developing new methods!). Lastly,  BenchmarkSimulations  allows one to compare between methods and easily plot the results.", 
            "title": "Extras for Developers and Researchers"
        }, 
        {
            "location": "/man/ODEProblem/", 
            "text": "Defining an ODE Problem\n\n\nTo define an ODE Problem, you simply need to give the function $f$ and the initial condition $u\u2080$ which define an ODE\n\n\n$$\ndu/dt = f(u,t)\n$$\n\n\nf\n should be specified as \nf(u,t)\n and \nu\u2080\n should be an AbstractArray whose geometry matches the desired geometry of \nu\n. Note that we are not limited to numbers or vectors for \nu\u2080\n, one is allowed to provide \nu\u2080\n as arbitrary matrices / higher dimension tensors as well.\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.ODEProblem\n \n \nType\n.\n\n\nODEProblem\n\n\nWraps the data which defines an SDE problem\n\n\n$$\ndu/dt = f(u,t)\n$$\n\n\nwith initial condition u\u2080.\n\n\nFields\n\n\n\n\nf\n: The drift function in the ODE.\n\n\nu\u2080\n: The initial condition.\n\n\nanalytic\n: A function which describes the solution.\n\n\nknownanalytic\n: True if the solution is given.\n\n\nnumvars\n: The number of variables in the system\n\n\nsizeu\n: The size of the initial condition (and thus \nu\n)\n\n\n\n\nConstructors\n\n\nODEProblem(f,u\u2080;analytic=nothing) : Defines the SDE with the specified functions and defines the solution if analytic is given.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nODEProblem\n(\nf\n, \nu\u2080\n)\n\n    defined at\n    \nsrc/general/problems.jl:388\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.twoDimlinearODEExample\n \n \nFunction\n.\n\n\nExample problem of 8 linear ODEs (as a 4x2 matrix) with solution $u(t)=exp(\u03b1.*t)$ and random initial conditions\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ntwoDimlinearODEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:12\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.linearODEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t)=u\u2080\nexp(\u03b1\nt)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nlinearODEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:5", 
            "title": "Defining an ODE Problem"
        }, 
        {
            "location": "/man/ODEProblem/#defining-an-ode-problem", 
            "text": "To define an ODE Problem, you simply need to give the function $f$ and the initial condition $u\u2080$ which define an ODE  $$\ndu/dt = f(u,t)\n$$  f  should be specified as  f(u,t)  and  u\u2080  should be an AbstractArray whose geometry matches the desired geometry of  u . Note that we are not limited to numbers or vectors for  u\u2080 , one is allowed to provide  u\u2080  as arbitrary matrices / higher dimension tensors as well.", 
            "title": "Defining an ODE Problem"
        }, 
        {
            "location": "/man/ODEProblem/#problem-type", 
            "text": "#  DifferentialEquations.ODEProblem     Type .  ODEProblem  Wraps the data which defines an SDE problem  $$\ndu/dt = f(u,t)\n$$  with initial condition u\u2080.  Fields   f : The drift function in the ODE.  u\u2080 : The initial condition.  analytic : A function which describes the solution.  knownanalytic : True if the solution is given.  numvars : The number of variables in the system  sizeu : The size of the initial condition (and thus  u )   Constructors  ODEProblem(f,u\u2080;analytic=nothing) : Defines the SDE with the specified functions and defines the solution if analytic is given.  source  Methods   \n     ODEProblem ( f ,  u\u2080 ) \n    defined at\n     src/general/problems.jl:388    Hiding 1 method defined outside of this package.", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/ODEProblem/#example-problems", 
            "text": "#  DifferentialEquations.twoDimlinearODEExample     Function .  Example problem of 8 linear ODEs (as a 4x2 matrix) with solution $u(t)=exp(\u03b1.*t)$ and random initial conditions  source  Methods   \n     twoDimlinearODEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:12    #  DifferentialEquations.linearODEExample     Function .  Example problem with solution $u(t)=u\u2080 exp(\u03b1 t)$  source  Methods   \n     linearODEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:5", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/SDEProblem/", 
            "text": "Defining a SDE Problem\n\n\nTo define an SDE Problem, you simply need to give the forcing function $f$, the noise function \n\u03c3\n, and the initial condition $u\u2080$ which define an SDE\n\n\n$$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$\n\n\nf\n and \n\u03c3\n should be specified as \nf(u,t)\n and  \n\u03c3(u,t)\n respectively, and \nu\u2080\n should be an AbstractArray whose geometry matches the desired geometry of \nu\n. Note that we are not limited to numbers or vectors for \nu\u2080\n, one is allowed to provide \nu\u2080\n as arbitrary matrices / higher dimension tensors as well. A vector of \n\u03c3\ns can also be defined to determine an SDE of higher Ito dimension.\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.SDEProblem\n \n \nType\n.\n\n\nSDEProblem\n\n\nWraps the data which defines an SDE problem\n\n\n$$\nu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$\n\n\nwith initial condition u\u2080.\n\n\nFields\n\n\n\n\nf\n: The drift function in the SDE.\n\n\n\u03c3\n: The noise function in the SDE.\n\n\nu\u2080\n: The initial condition.\n\n\nanalytic\n: A function which describes the solution.\n\n\nknownanalytic\n: True if the solution is given.\n\n\nnumvars\n: The number of variables in the system\n\n\nsizeu\n: The size of the initial condition (and thus \nu\n)\n\n\n\n\nConstructors\n\n\nSDEProblem(f,\u03c3,u\u2080;analytic=nothing) : Defines the SDE with the specified functions and defines the solution if analytic is given.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nSDEProblem\n(\n\n    \nf\n,\n\n    \n\u03c3\n,\n\n    \nu\u2080\n\n\n)\n\n    defined at\n    \nsrc/general/problems.jl:337\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.twoDimlinearSDEExample\n \n \nFunction\n.\n\n\nExample problem of 8 linear SDEs (as a 4x2 matrix) with solution $u(t,W)=u\u2080\nexp((\u03b1-(\u03b2^2)/2)\nt+\u03b2*W)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ntwoDimlinearSDEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:37\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.cubicSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t,W)=((1+u\u2080)\nexp(W)+u\u2080-1)./((1+u\u2080)\nexp(W)+1-u\u2080)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncubicSDEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:45\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.linearSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t,W)=u\u2080\nexp((\u03b1-(\u03b2^2)/2)\nt+\u03b2*W)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nlinearSDEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:29\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.multiDimAdditiveSDEExample\n \n \nFunction\n.\n\n\nMultiple Ito dimension extension of additiveSDEExample\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmultiDimAdditiveSDEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:69\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.waveSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution $u(t,W)=atan(0.1*W + tan(u\u2080))$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nwaveSDEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:53\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.additiveSDEExample\n \n \nFunction\n.\n\n\nExample additive noise problem with solution $u\u2080./sqrt(1+t) + \u03b2\n(t+\u03b1\nW)./sqrt(1+t)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nadditiveSDEExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:61", 
            "title": "Defining an SDE Problem"
        }, 
        {
            "location": "/man/SDEProblem/#defining-a-sde-problem", 
            "text": "To define an SDE Problem, you simply need to give the forcing function $f$, the noise function  \u03c3 , and the initial condition $u\u2080$ which define an SDE  $$\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$  f  and  \u03c3  should be specified as  f(u,t)  and   \u03c3(u,t)  respectively, and  u\u2080  should be an AbstractArray whose geometry matches the desired geometry of  u . Note that we are not limited to numbers or vectors for  u\u2080 , one is allowed to provide  u\u2080  as arbitrary matrices / higher dimension tensors as well. A vector of  \u03c3 s can also be defined to determine an SDE of higher Ito dimension.", 
            "title": "Defining a SDE Problem"
        }, 
        {
            "location": "/man/SDEProblem/#problem-type", 
            "text": "#  DifferentialEquations.SDEProblem     Type .  SDEProblem  Wraps the data which defines an SDE problem  $$\nu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n$$  with initial condition u\u2080.  Fields   f : The drift function in the SDE.  \u03c3 : The noise function in the SDE.  u\u2080 : The initial condition.  analytic : A function which describes the solution.  knownanalytic : True if the solution is given.  numvars : The number of variables in the system  sizeu : The size of the initial condition (and thus  u )   Constructors  SDEProblem(f,\u03c3,u\u2080;analytic=nothing) : Defines the SDE with the specified functions and defines the solution if analytic is given.  source  Methods   \n     SDEProblem ( \n     f ,      \u03c3 ,      u\u2080  ) \n    defined at\n     src/general/problems.jl:337    Hiding 1 method defined outside of this package.", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/SDEProblem/#example-problems", 
            "text": "#  DifferentialEquations.twoDimlinearSDEExample     Function .  Example problem of 8 linear SDEs (as a 4x2 matrix) with solution $u(t,W)=u\u2080 exp((\u03b1-(\u03b2^2)/2) t+\u03b2*W)$  source  Methods   \n     twoDimlinearSDEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:37    #  DifferentialEquations.cubicSDEExample     Function .  Example problem with solution $u(t,W)=((1+u\u2080) exp(W)+u\u2080-1)./((1+u\u2080) exp(W)+1-u\u2080)$  source  Methods   \n     cubicSDEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:45    #  DifferentialEquations.linearSDEExample     Function .  Example problem with solution $u(t,W)=u\u2080 exp((\u03b1-(\u03b2^2)/2) t+\u03b2*W)$  source  Methods   \n     linearSDEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:29    #  DifferentialEquations.multiDimAdditiveSDEExample     Function .  Multiple Ito dimension extension of additiveSDEExample  source  Methods   \n     multiDimAdditiveSDEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:69    #  DifferentialEquations.waveSDEExample     Function .  Example problem with solution $u(t,W)=atan(0.1*W + tan(u\u2080))$  source  Methods   \n     waveSDEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:53    #  DifferentialEquations.additiveSDEExample     Function .  Example additive noise problem with solution $u\u2080./sqrt(1+t) + \u03b2 (t+\u03b1 W)./sqrt(1+t)$  source  Methods   \n     additiveSDEExample ( ) \n    defined at\n     src/premades/premade_problems.jl:61", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/FEMProblem/", 
            "text": "Defining a FEM Problem\n\n\nBelow are the definitions of the types which specify problems. Some general notes are:\n\n\n\n\n(x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as $f(x,y,t)$.\n\n\n\n\nHowever, in this code we use \nx\n as a vector. Thus you can think of $x$=\nx[:,1]\n and $y$=\nx[:,2]\n. Thus input equations are of the form \nf(x,t)\n no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use \nf(x)\n. An example is the equation $u(x,y)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)$ would be specified as \nsol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n. * Linearity: If the equation has linear term, they are specified with functions \nf(x,t)\n. If it is nonlinear, it is specified with functions \nf(u,x,t)\n. The boundary conditions are always \n(x,t)\n * Stochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic $\u03c3(u,x,t)dW_t$ term to the equation (or with $\u03c3(x,t)dW_t$ if linear, must match \nf\n). $dW_t$ corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.\n\n\n\n\nPoisson Equation Problem\n\n\n#\n\n\nDifferentialEquations.PoissonProblem\n \n \nType\n.\n\n\nPoissonProblem\n\n\nWraps the data that define a 2D linear Poisson equation problem:\n\n\n$$\n-\u0394u = f\n$$\n\n\nwith bounday conditions \ngD\n on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\n$$\n-\u0394u = f + \u03c3dW\n$$\n\n\nConstructors\n\n\nPoissonProblem(f,analytic,Du): Defines the dirichlet problem with analytical solution \nanalytic\n, solution gradient \nDu = [u_x,u_y]\n, and forcing function \nf\n\n\nPoissonProblem(u\u2080,f): Defines the problem with initial value \nu\u2080\n (as a function) and f. If your initial data is a vector, wrap it as u\u2080(x) = vector.\n\n\nNote: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))\n\n\nKeyword Arguments\n\n\n\n\ngD\n = dirichlet boundary function\n\n\ngN\n = neumann boundary function\n\n\n\u03c3\n = The function which multiplies the noise $dW$. By default \n\u03c3\n is 0.\n\n\nnoisetype\n = A string which specifies the type of noise to be generated. By default\n\n\n\n\nnoisetype\n is :White for Gaussian Spacetime White Noise.\n\n\n\n\nnumvars\n = The number of variables in the Poisson system. Automatically calculated in many cases.\n\n\nD\n = Vector of diffusion coefficients. Defaults to ones.\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nPoissonProblem\n(\nf\n)\n\n    defined at\n    \nsrc/general/problems.jl:248\n\n\n\n\n\n    \nPoissonProblem\n(\n\n    \nf\n,\n\n    \nanalytic\n,\n\n    \nDu\n\n\n)\n\n    defined at\n    \nsrc/general/problems.jl:221\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nHeat Equation Problem\n\n\n#\n\n\nDifferentialEquations.HeatProblem\n \n \nType\n.\n\n\nHeatProblem\n\n\nWraps the data that define a 2D heat equation problem:\n\n\n$$\nu_t = \u0394u + f\n$$\n\n\nwith bounday conditions \ngD\n on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\n$$\nu_t = \u0394u + f + \u03c3dW_t\n$$\n\n\nConstructors\n\n\n\n\nHeatProblem(analytic,Du,f)\n: Defines the dirichlet problem with solution \nanalytic\n,\n\n\n\n\nsolution gradient \nDu = [u_x,u_y]\n, and the forcing function \nf\n.\n\n\n\n\nHeatProblem(u\u2080,f)\n: Defines the problem with initial value \nu\u2080\n (as a function) and \nf\n.\n\n\n\n\nIf your initial data is a vector, wrap it as u\u2080(x) = vector.\n\n\nNote: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))\n\n\nKeyword Arguments\n\n\n\n\ngD\n = dirichlet boundary function\n\n\ngN\n = neumann boundary function\n\n\n\u03c3\n = The function which multiplies the noise dW. By default \u03c3 is 0.\n\n\nnoisetype\n = A string which specifies the type of noise to be generated. By default\n\n\n\n\nnoisetype is :White for Gaussian Spacetime White Noise.\n\n\n\n\nnumvars\n = Number of variables in the system. Automatically calculated from u\u2080 in most cases.\n\n\nD\n = Array which defines the diffusion coefficients. Defaults to 1's.\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nHeatProblem\n(\nu\u2080\n, \nf\n)\n\n    defined at\n    \nsrc/general/problems.jl:96\n\n\n\n\n\n    \nHeatProblem\n(\n\n    \nanalytic\n,\n\n    \nDu\n,\n\n    \nf\n\n\n)\n\n    defined at\n    \nsrc/general/problems.jl:70\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nExample Problems\n\n\n\n\nPoisson Equation\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_wave\n \n \nFunction\n.\n\n\nExample problem with solution: $u(x,y)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npoissonProblemExample_wave\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:331\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n \n \nFunction\n.\n\n\nExample problem with deterministic solution: $u(x,y)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npoissonProblemExample_noisyWave\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:339\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem for nonlinear Poisson equation. Uses $f(u)=1-u/2$.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npoissonProblemExample_birthdeath\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:348\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeathinteractingsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npoissonProblemExample_birthdeathinteractingsystem\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:364\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeathsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npoissonProblemExample_birthdeathsystem\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:355\n\n\n\n\n\n\n\n\n\nHeat Equation\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffuse\n \n \nFunction\n.\n\n\nExample problem with solution: $u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_diffuse\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:253\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_pure\n \n \nFunction\n.\n\n\nExample problem which starts with 1 at (0.5,0.5) and solves with $f=gD=0$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_pure\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:261\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_moving\n \n \nFunction\n.\n\n\nExample problem with solution: $u(x,y,t)=0.1\n(1-exp(-100\n(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_moving\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:242\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with $f(u)=1-u/2$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_birthdeath\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:268\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with $f(u)=1-u/2$ with noise $\u03c3(u)=10u^2$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_stochasticbirthdeath\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:323\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeathinteractingsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_birthdeathinteractingsystem\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:293\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_gierermeinhardt\n \n \nFunction\n.\n\n\nExample problem which solves the Gierer-Meinhardt equations wtih quasi-random initial perturbations.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_gierermeinhardt\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:312\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeathsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_birthdeathsystem\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:275\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffusionconstants\n \n \nFunction\n.\n\n\nExample problem which solves the homogeneous Heat equation with all mass starting at (1/2,1/2) with two different diffusion constants.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_diffusionconstants\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:284\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_grayscott\n \n \nFunction\n.\n\n\nExample problem which solves the Gray-Scott equations with quasi-random initial conditions\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nheatProblemExample_grayscott\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:302\n\n\n\n\n\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.DEProblem\n \n \nType\n.\n\n\nPdeProblem: Defines differential equation problems via its internal functions\n\n\nsource", 
            "title": "Defining a Finite Element Problem"
        }, 
        {
            "location": "/man/FEMProblem/#defining-a-fem-problem", 
            "text": "Below are the definitions of the types which specify problems. Some general notes are:   (x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as $f(x,y,t)$.   However, in this code we use  x  as a vector. Thus you can think of $x$= x[:,1]  and $y$= x[:,2] . Thus input equations are of the form  f(x,t)  no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use  f(x) . An example is the equation $u(x,y)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)$ would be specified as  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0) . * Linearity: If the equation has linear term, they are specified with functions  f(x,t) . If it is nonlinear, it is specified with functions  f(u,x,t) . The boundary conditions are always  (x,t)  * Stochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic $\u03c3(u,x,t)dW_t$ term to the equation (or with $\u03c3(x,t)dW_t$ if linear, must match  f ). $dW_t$ corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.", 
            "title": "Defining a FEM Problem"
        }, 
        {
            "location": "/man/FEMProblem/#poisson-equation-problem", 
            "text": "#  DifferentialEquations.PoissonProblem     Type .  PoissonProblem  Wraps the data that define a 2D linear Poisson equation problem:  $$\n-\u0394u = f\n$$  with bounday conditions  gD  on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  $$\n-\u0394u = f + \u03c3dW\n$$", 
            "title": "Poisson Equation Problem"
        }, 
        {
            "location": "/man/FEMProblem/#constructors", 
            "text": "PoissonProblem(f,analytic,Du): Defines the dirichlet problem with analytical solution  analytic , solution gradient  Du = [u_x,u_y] , and forcing function  f  PoissonProblem(u\u2080,f): Defines the problem with initial value  u\u2080  (as a function) and f. If your initial data is a vector, wrap it as u\u2080(x) = vector.  Note: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/FEMProblem/#keyword-arguments", 
            "text": "gD  = dirichlet boundary function  gN  = neumann boundary function  \u03c3  = The function which multiplies the noise $dW$. By default  \u03c3  is 0.  noisetype  = A string which specifies the type of noise to be generated. By default   noisetype  is :White for Gaussian Spacetime White Noise.   numvars  = The number of variables in the Poisson system. Automatically calculated in many cases.  D  = Vector of diffusion coefficients. Defaults to ones.   source  Methods   \n     PoissonProblem ( f ) \n    defined at\n     src/general/problems.jl:248   \n     PoissonProblem ( \n     f ,      analytic ,      Du  ) \n    defined at\n     src/general/problems.jl:221    Hiding 1 method defined outside of this package.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/FEMProblem/#heat-equation-problem", 
            "text": "#  DifferentialEquations.HeatProblem     Type .  HeatProblem  Wraps the data that define a 2D heat equation problem:  $$\nu_t = \u0394u + f\n$$  with bounday conditions  gD  on the dirichlet boundary and gN on the neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  $$\nu_t = \u0394u + f + \u03c3dW_t\n$$", 
            "title": "Heat Equation Problem"
        }, 
        {
            "location": "/man/FEMProblem/#constructors_1", 
            "text": "HeatProblem(analytic,Du,f) : Defines the dirichlet problem with solution  analytic ,   solution gradient  Du = [u_x,u_y] , and the forcing function  f .   HeatProblem(u\u2080,f) : Defines the problem with initial value  u\u2080  (as a function) and  f .   If your initial data is a vector, wrap it as u\u2080(x) = vector.  Note: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/FEMProblem/#keyword-arguments_1", 
            "text": "gD  = dirichlet boundary function  gN  = neumann boundary function  \u03c3  = The function which multiplies the noise dW. By default \u03c3 is 0.  noisetype  = A string which specifies the type of noise to be generated. By default   noisetype is :White for Gaussian Spacetime White Noise.   numvars  = Number of variables in the system. Automatically calculated from u\u2080 in most cases.  D  = Array which defines the diffusion coefficients. Defaults to 1's.   source  Methods   \n     HeatProblem ( u\u2080 ,  f ) \n    defined at\n     src/general/problems.jl:96   \n     HeatProblem ( \n     analytic ,      Du ,      f  ) \n    defined at\n     src/general/problems.jl:70    Hiding 1 method defined outside of this package.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/FEMProblem/#example-problems", 
            "text": "", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/FEMProblem/#poisson-equation", 
            "text": "#  DifferentialEquations.poissonProblemExample_wave     Function .  Example problem with solution: $u(x,y)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)$  source  Methods   \n     poissonProblemExample_wave ( ) \n    defined at\n     src/premades/premade_problems.jl:331    #  DifferentialEquations.poissonProblemExample_noisyWave     Function .  Example problem with deterministic solution: $u(x,y)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)$  source  Methods   \n     poissonProblemExample_noisyWave ( ) \n    defined at\n     src/premades/premade_problems.jl:339    #  DifferentialEquations.poissonProblemExample_birthdeath     Function .  Example problem for nonlinear Poisson equation. Uses $f(u)=1-u/2$.  source  Methods   \n     poissonProblemExample_birthdeath ( ) \n    defined at\n     src/premades/premade_problems.jl:348    #  DifferentialEquations.poissonProblemExample_birthdeathinteractingsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$  source  Methods   \n     poissonProblemExample_birthdeathinteractingsystem ( ) \n    defined at\n     src/premades/premade_problems.jl:364    #  DifferentialEquations.poissonProblemExample_birthdeathsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$  source  Methods   \n     poissonProblemExample_birthdeathsystem ( ) \n    defined at\n     src/premades/premade_problems.jl:355", 
            "title": "Poisson Equation"
        }, 
        {
            "location": "/man/FEMProblem/#heat-equation", 
            "text": "#  DifferentialEquations.heatProblemExample_diffuse     Function .  Example problem with solution: $u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)$  source  Methods   \n     heatProblemExample_diffuse ( ) \n    defined at\n     src/premades/premade_problems.jl:253    #  DifferentialEquations.heatProblemExample_pure     Function .  Example problem which starts with 1 at (0.5,0.5) and solves with $f=gD=0$  source  Methods   \n     heatProblemExample_pure ( ) \n    defined at\n     src/premades/premade_problems.jl:261    #  DifferentialEquations.heatProblemExample_moving     Function .  Example problem with solution: $u(x,y,t)=0.1 (1-exp(-100 (t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))$  source  Methods   \n     heatProblemExample_moving ( ) \n    defined at\n     src/premades/premade_problems.jl:242    #  DifferentialEquations.heatProblemExample_birthdeath     Function .  Example problem which starts with 0 and solves with $f(u)=1-u/2$  source  Methods   \n     heatProblemExample_birthdeath ( ) \n    defined at\n     src/premades/premade_problems.jl:268    #  DifferentialEquations.heatProblemExample_stochasticbirthdeath     Function .  Example problem which starts with 0 and solves with $f(u)=1-u/2$ with noise $\u03c3(u)=10u^2$  source  Methods   \n     heatProblemExample_stochasticbirthdeath ( ) \n    defined at\n     src/premades/premade_problems.jl:323    #  DifferentialEquations.heatProblemExample_birthdeathinteractingsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=.5u-v$  source  Methods   \n     heatProblemExample_birthdeathinteractingsystem ( ) \n    defined at\n     src/premades/premade_problems.jl:293    #  DifferentialEquations.heatProblemExample_gierermeinhardt     Function .  Example problem which solves the Gierer-Meinhardt equations wtih quasi-random initial perturbations.  source  Methods   \n     heatProblemExample_gierermeinhardt ( ) \n    defined at\n     src/premades/premade_problems.jl:312    #  DifferentialEquations.heatProblemExample_birthdeathsystem     Function .  Example problem which starts with 1/2 and solves the system $f(u)=1-u/2$ and $f(v)=1-v$  source  Methods   \n     heatProblemExample_birthdeathsystem ( ) \n    defined at\n     src/premades/premade_problems.jl:275    #  DifferentialEquations.heatProblemExample_diffusionconstants     Function .  Example problem which solves the homogeneous Heat equation with all mass starting at (1/2,1/2) with two different diffusion constants.  source  Methods   \n     heatProblemExample_diffusionconstants ( ) \n    defined at\n     src/premades/premade_problems.jl:284    #  DifferentialEquations.heatProblemExample_grayscott     Function .  Example problem which solves the Gray-Scott equations with quasi-random initial conditions  source  Methods   \n     heatProblemExample_grayscott ( ) \n    defined at\n     src/premades/premade_problems.jl:302", 
            "title": "Heat Equation"
        }, 
        {
            "location": "/man/FEMProblem/#related-functions", 
            "text": "#  DifferentialEquations.DEProblem     Type .  PdeProblem: Defines differential equation problems via its internal functions  source", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/StokesProblem/", 
            "text": "Defining a Stokes Problem\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.StokesProblem\n \n \nType\n.\n\n\nStokesProblem\n\n\nDefines the solution to a stationary Stokes problem:\n\n\n$$\n\n\n$$\n\n\nFields\n\n\n\n\nf\u2081::Function\n\n\nf\u2082::Function\n\n\ng::Function\n\n\nugD::Function\n\n\nvgD::Function\n\n\nuanalytic::Function\n\n\nvanalytic::Function\n\n\npanalytic::Function\n\n\ntrueknown::Bool\n\n\n\n\nConstructors\n\n\nStokesProblem(f\u2081,f\u2082,g,uanalytic,vanalytic,panalytic)\n\n\nStokesProblem(f\u2081,f\u2082,g,ugD,vgD)\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nStokesProblem\n(\n\n    \nf\u2081\n,\n\n    \nf\u2082\n,\n\n    \ng\n,\n\n    \nugD\n,\n\n    \nvgD\n\n\n)\n\n    defined at\n    \nsrc/general/problems.jl:443\n\n\n\n\n\n    \nStokesProblem\n(\n\n    \nf\u2081\n,\n\n    \nf\u2082\n,\n\n    \ng\n,\n\n    \nuanalytic\n,\n\n    \nvanalytic\n,\n\n    \npanalytic\n\n\n)\n\n    defined at\n    \nsrc/general/problems.jl:442\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.dirichletzeroStokesExample\n \n \nFunction\n.\n\n\nExample problme for solving the trivial stationary Stokes equation.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ndirichletzeroStokesExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:386\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.homogeneousStokesExample\n \n \nFunction\n.\n\n\nExample problem for a homogeneous stationary Stokes equation.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nhomogeneousStokesExample\n(\n)\n\n    defined at\n    \nsrc/premades/premade_problems.jl:375", 
            "title": "Defining a Stokes Problem"
        }, 
        {
            "location": "/man/StokesProblem/#defining-a-stokes-problem", 
            "text": "", 
            "title": "Defining a Stokes Problem"
        }, 
        {
            "location": "/man/StokesProblem/#problem-type", 
            "text": "#  DifferentialEquations.StokesProblem     Type .  StokesProblem  Defines the solution to a stationary Stokes problem:  $$  $$  Fields   f\u2081::Function  f\u2082::Function  g::Function  ugD::Function  vgD::Function  uanalytic::Function  vanalytic::Function  panalytic::Function  trueknown::Bool   Constructors  StokesProblem(f\u2081,f\u2082,g,uanalytic,vanalytic,panalytic)  StokesProblem(f\u2081,f\u2082,g,ugD,vgD)  source  Methods   \n     StokesProblem ( \n     f\u2081 ,      f\u2082 ,      g ,      ugD ,      vgD  ) \n    defined at\n     src/general/problems.jl:443   \n     StokesProblem ( \n     f\u2081 ,      f\u2082 ,      g ,      uanalytic ,      vanalytic ,      panalytic  ) \n    defined at\n     src/general/problems.jl:442    Hiding 1 method defined outside of this package.", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/StokesProblem/#example-problems", 
            "text": "#  DifferentialEquations.dirichletzeroStokesExample     Function .  Example problme for solving the trivial stationary Stokes equation.  source  Methods   \n     dirichletzeroStokesExample ( ) \n    defined at\n     src/premades/premade_problems.jl:386    #  DifferentialEquations.homogeneousStokesExample     Function .  Example problem for a homogeneous stationary Stokes equation.  source  Methods   \n     homogeneousStokesExample ( ) \n    defined at\n     src/premades/premade_problems.jl:375", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/mesh/", 
            "text": "Meshes\n\n\n\n\nMesh Specification\n\n\nFinite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:\n\n\n\n\nRow $i$ of node is an $(x,y)$ (or $(x,y,z)$) pair which specifies the coordinates\n\n\n\n\nof the $i$th node. * Row $j$ of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.\n\n\nFor example, to know the $(x,y)$ locations of the vertices of triangle $j$, we would see that $node[elem[j,i],:]$ are the $(x,y)$ locations of the $i$th vertex for $i=1,2,3$.\n\n\nFor more information, please see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\n\n\nMesh Type\n\n\n#\n\n\nDifferentialEquations.FEMmesh\n \n \nType\n.\n\n\nFEMmesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\nbdnode\n: Vector of indices for the boundary nodes.\n\n\nfreenode\n: Vector of indices for the free (non-dirichlet bound) nodes.\n\n\nbdedge\n: Indices of the edges in totaledge which are on the boundary.\n\n\nis_bdnode\n: Boolean which is true for nodes on the boundary.\n\n\nis_bdelem\n: Boolean which is true for elements on the boundary.\n\n\nbdflag\n: Flag which describes the type of boundary condition. 1=\n dirichlet,\n\n\n\n\n2=\nneumann, 3=\nrobin. * \ntotaledge\n: Vector of the edges. * \narea\n: Vector which is the area for each element. * \ndirichlet\n: Indices for the nodes on the boundary which have a dirichlet boundary condition. * \nneumann\n: Indices for the nodes on the boundary which have a neumann boundary condition. * \nrobin\n: Indices for the nodes on the boundary which have a robin boundary condition. * \nN::Int\n: The number of nodes. * \nNT\n::Int: The number of triangles (elements). * \n\u0394x\n: The spatial discretization size. If non-uniform, this is the average. * \n\u0394t\n: The time discretization size. If adaptive, this is the initial. * \nT\n::Number: The end time. * \nnumiters\n::Int: The number of iterations to go from 0 to T using \u0394t. * \n\u03bc\n: The CFL \u03bc stability parameter. * \n\u03bd\n: The CFL \u03bd stability parameter. * \nevolutionEq\n: True for a mesh which has non-trivial time components.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nFEMmesh\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \n\u0394x\n,\n\n    \nbdtype\n\n\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:86\n\n\n\n\n\n    \nFEMmesh\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \n\u0394x\n,\n\n    \n\u0394t\n,\n\n    \nT\n,\n\n    \nbdtype\n\n\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:58\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.SimpleMesh\n \n \nType\n.\n\n\nSimpleMesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nSimpleMesh\n(\nnode\n, \nelem\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:105\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.Mesh\n \n \nType\n.\n\n\nMesh: An abstract type which holds a (node,elem) pair and other information for a mesh\n\n\nsource\n\n\n\n\nMesh Generation Functions\n\n\n#\n\n\nDifferentialEquations.findboundary\n \n \nFunction\n.\n\n\nfindboundary(elem,bdflag=[])\n\n\nfindboundary(fem_mesh::FEMmesh,bdflag=[])\n\n\nFinds elements which are on the boundary of the domain. If bdflag is given, then those indices are added as nodes for a dirichlet boundary condition (useful for creating cracks and other cutouts of domains).\n\n\nReturns\n\n\nbdnode = Vector of indices for bdnode. Using node[:,bdnode] returns boundary nodes.\n\n\nbdedge = Vector of indices for boundary edges.\n\n\nis_bdnode = Vector of booleans size N which donotes which are on the boundary\n\n\nis_bdelem = Vector of booleans size NT which denotes which are on the boundary\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nfindboundary\n(\nelem\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/fem/fem_boundary.jl:21\n\n\n\n\n\n    \nfindboundary\n(\nfem_mesh\n::\nDifferentialEquations.Mesh\n)\n\n    defined at\n    \nsrc/fem/fem_boundary.jl:48\n\n\n\n\n\n    \nfindboundary\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.Mesh\n,\n\n    \nbdflag\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_boundary.jl:48\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.setboundary\n \n \nFunction\n.\n\n\nsetboundary(node::AbstractArray,elem::AbstractArray,bdtype)\n\n\nsetboundary(fem_mesh::FEMmesh,bdtype)\n\n\nTakes in the fem_mesh and creates an array bdflag which denotes the boundary types. 1 stands for dirichlet, 2 for neumann, 3 for robin.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsetboundary\n(\n\n    \nnode\n::\nAbstractArray\n,\n\n    \nelem\n::\nAbstractArray\n,\n\n    \nbdtype\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_boundary.jl:60\n\n\n\n\n\n    \nsetboundary\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.Mesh\n,\n\n    \nbdtype\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_boundary.jl:110\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.fem_squaremesh\n \n \nFunction\n.\n\n\nfem_squaremesh(square,h)\n\n\nReturns the grid in the iFEM form of the two arrays (node,elem)\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nfem_squaremesh\n(\nsquare\n, \nh\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:130\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.notime_squaremesh\n \n \nFunction\n.\n\n\nnotime_squaremesh(square,\u0394x,bdtype)\n\n\nComputes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x,\ndirichlet\n)\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nnotime_squaremesh\n(\n\n    \nsquare\n,\n\n    \n\u0394x\n,\n\n    \nbdtype\n\n\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:160\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.parabolic_squaremesh\n \n \nFunction\n.\n\n\nparabolic_squaremesh(square,\u0394x,\u0394t,T,bdtype)\n\n\nComputes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,:dirichlet)\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nparabolic_squaremesh\n(\n\n    \nsquare\n,\n\n    \n\u0394x\n,\n\n    \n\u0394t\n,\n\n    \nT\n,\n\n    \nbdtype\n\n\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:179\n\n\n\n\n\n\n\n\n\nExample Meshes\n\n\n#\n\n\nDifferentialEquations.meshExample_bunny\n \n \nFunction\n.\n\n\nmeshExample_bunny() : Returns a 3D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_bunny\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:6\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n \n \nFunction\n.\n\n\nmeshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_flowpastcylindermesh\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:9\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_lakemesh\n \n \nFunction\n.\n\n\nmeshExample_lakemesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_lakemesh\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:12\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapemesh\n \n \nFunction\n.\n\n\nmeshExample_Lshapemesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_Lshapemesh\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:15\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n \n \nFunction\n.\n\n\nmeshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_Lshapeunstructure\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:18\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_oilpump\n \n \nFunction\n.\n\n\nmeshExample_oilpump() : Returns a 3D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_oilpump\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:21\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_wavymesh\n \n \nFunction\n.\n\n\nmeshExample_wavymesh() : Returns a 2D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_wavymesh\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:24\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n \n \nFunction\n.\n\n\nmeshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmeshExample_wavyperturbmesh\n(\n)\n\n    defined at\n    \nsrc/premades/premade_meshes.jl:27\n\n\n\n\n\n\n\n\n\nPlot Functions\n\n\nThe plot functionality is provided by a Plots.jl recipe. What is plotted is a \"trisurf\" of the mesh. To plot a mesh, simply use:\n\n\nplot(mesh::Mesh)\n\n\n\n\nAll of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#meshes", 
            "text": "", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#mesh-specification", 
            "text": "Finite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:   Row $i$ of node is an $(x,y)$ (or $(x,y,z)$) pair which specifies the coordinates   of the $i$th node. * Row $j$ of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.  For example, to know the $(x,y)$ locations of the vertices of triangle $j$, we would see that $node[elem[j,i],:]$ are the $(x,y)$ locations of the $i$th vertex for $i=1,2,3$.  For more information, please see  Programming of Finite Element Methods by Long Chen .", 
            "title": "Mesh Specification"
        }, 
        {
            "location": "/man/mesh/#mesh-type", 
            "text": "#  DifferentialEquations.FEMmesh     Type .  FEMmesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.  bdnode : Vector of indices for the boundary nodes.  freenode : Vector of indices for the free (non-dirichlet bound) nodes.  bdedge : Indices of the edges in totaledge which are on the boundary.  is_bdnode : Boolean which is true for nodes on the boundary.  is_bdelem : Boolean which is true for elements on the boundary.  bdflag : Flag which describes the type of boundary condition. 1=  dirichlet,   2= neumann, 3= robin. *  totaledge : Vector of the edges. *  area : Vector which is the area for each element. *  dirichlet : Indices for the nodes on the boundary which have a dirichlet boundary condition. *  neumann : Indices for the nodes on the boundary which have a neumann boundary condition. *  robin : Indices for the nodes on the boundary which have a robin boundary condition. *  N::Int : The number of nodes. *  NT ::Int: The number of triangles (elements). *  \u0394x : The spatial discretization size. If non-uniform, this is the average. *  \u0394t : The time discretization size. If adaptive, this is the initial. *  T ::Number: The end time. *  numiters ::Int: The number of iterations to go from 0 to T using \u0394t. *  \u03bc : The CFL \u03bc stability parameter. *  \u03bd : The CFL \u03bd stability parameter. *  evolutionEq : True for a mesh which has non-trivial time components.  source  Methods   \n     FEMmesh ( \n     node ,      elem ,      \u0394x ,      bdtype  ) \n    defined at\n     src/fem/meshes.jl:86   \n     FEMmesh ( \n     node ,      elem ,      \u0394x ,      \u0394t ,      T ,      bdtype  ) \n    defined at\n     src/fem/meshes.jl:58    Hiding 1 method defined outside of this package.  #  DifferentialEquations.SimpleMesh     Type .  SimpleMesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see  Programming of Finite Element Methods by Long Chen .  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.   source  Methods   \n     SimpleMesh ( node ,  elem ) \n    defined at\n     src/fem/meshes.jl:105    Hiding 1 method defined outside of this package.  #  DifferentialEquations.Mesh     Type .  Mesh: An abstract type which holds a (node,elem) pair and other information for a mesh  source", 
            "title": "Mesh Type"
        }, 
        {
            "location": "/man/mesh/#mesh-generation-functions", 
            "text": "#  DifferentialEquations.findboundary     Function .  findboundary(elem,bdflag=[])  findboundary(fem_mesh::FEMmesh,bdflag=[])  Finds elements which are on the boundary of the domain. If bdflag is given, then those indices are added as nodes for a dirichlet boundary condition (useful for creating cracks and other cutouts of domains).  Returns  bdnode = Vector of indices for bdnode. Using node[:,bdnode] returns boundary nodes.  bdedge = Vector of indices for boundary edges.  is_bdnode = Vector of booleans size N which donotes which are on the boundary  is_bdelem = Vector of booleans size NT which denotes which are on the boundary  source  Methods   \n     findboundary ( elem :: AbstractArray ) \n    defined at\n     src/fem/fem_boundary.jl:21   \n     findboundary ( fem_mesh :: DifferentialEquations.Mesh ) \n    defined at\n     src/fem/fem_boundary.jl:48   \n     findboundary ( \n     fem_mesh :: DifferentialEquations.Mesh ,      bdflag  ) \n    defined at\n     src/fem/fem_boundary.jl:48    #  DifferentialEquations.setboundary     Function .  setboundary(node::AbstractArray,elem::AbstractArray,bdtype)  setboundary(fem_mesh::FEMmesh,bdtype)  Takes in the fem_mesh and creates an array bdflag which denotes the boundary types. 1 stands for dirichlet, 2 for neumann, 3 for robin.  source  Methods   \n     setboundary ( \n     node :: AbstractArray ,      elem :: AbstractArray ,      bdtype  ) \n    defined at\n     src/fem/fem_boundary.jl:60   \n     setboundary ( \n     fem_mesh :: DifferentialEquations.Mesh ,      bdtype  ) \n    defined at\n     src/fem/fem_boundary.jl:110    #  DifferentialEquations.fem_squaremesh     Function .  fem_squaremesh(square,h)  Returns the grid in the iFEM form of the two arrays (node,elem)  source  Methods   \n     fem_squaremesh ( square ,  h ) \n    defined at\n     src/fem/meshes.jl:130    #  DifferentialEquations.notime_squaremesh     Function .  notime_squaremesh(square,\u0394x,bdtype)  Computes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.", 
            "title": "Mesh Generation Functions"
        }, 
        {
            "location": "/man/mesh/#example", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x, dirichlet )  source  Methods   \n     notime_squaremesh ( \n     square ,      \u0394x ,      bdtype  ) \n    defined at\n     src/fem/meshes.jl:160    #  DifferentialEquations.parabolic_squaremesh     Function .  parabolic_squaremesh(square,\u0394x,\u0394t,T,bdtype)  Computes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example_1", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,:dirichlet)  source  Methods   \n     parabolic_squaremesh ( \n     square ,      \u0394x ,      \u0394t ,      T ,      bdtype  ) \n    defined at\n     src/fem/meshes.jl:179", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example-meshes", 
            "text": "#  DifferentialEquations.meshExample_bunny     Function .  meshExample_bunny() : Returns a 3D SimpleMesh.  source  Methods   \n     meshExample_bunny ( ) \n    defined at\n     src/premades/premade_meshes.jl:6    #  DifferentialEquations.meshExample_flowpastcylindermesh     Function .  meshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.  source  Methods   \n     meshExample_flowpastcylindermesh ( ) \n    defined at\n     src/premades/premade_meshes.jl:9    #  DifferentialEquations.meshExample_lakemesh     Function .  meshExample_lakemesh() : Returns a 2D SimpleMesh.  source  Methods   \n     meshExample_lakemesh ( ) \n    defined at\n     src/premades/premade_meshes.jl:12    #  DifferentialEquations.meshExample_Lshapemesh     Function .  meshExample_Lshapemesh() : Returns a 2D SimpleMesh.  source  Methods   \n     meshExample_Lshapemesh ( ) \n    defined at\n     src/premades/premade_meshes.jl:15    #  DifferentialEquations.meshExample_Lshapeunstructure     Function .  meshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.  source  Methods   \n     meshExample_Lshapeunstructure ( ) \n    defined at\n     src/premades/premade_meshes.jl:18    #  DifferentialEquations.meshExample_oilpump     Function .  meshExample_oilpump() : Returns a 3D SimpleMesh.  source  Methods   \n     meshExample_oilpump ( ) \n    defined at\n     src/premades/premade_meshes.jl:21    #  DifferentialEquations.meshExample_wavymesh     Function .  meshExample_wavymesh() : Returns a 2D SimpleMesh.  source  Methods   \n     meshExample_wavymesh ( ) \n    defined at\n     src/premades/premade_meshes.jl:24    #  DifferentialEquations.meshExample_wavyperturbmesh     Function .  meshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.  source  Methods   \n     meshExample_wavyperturbmesh ( ) \n    defined at\n     src/premades/premade_meshes.jl:27", 
            "title": "Example Meshes"
        }, 
        {
            "location": "/man/mesh/#plot-functions", 
            "text": "The plot functionality is provided by a Plots.jl recipe. What is plotted is a \"trisurf\" of the mesh. To plot a mesh, simply use:  plot(mesh::Mesh)  All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/solution/", 
            "text": "The Solution Type\n\n\nEach solver has an appropriate solution type. The solution type holds all of the information about the problem which was solved an its solution. If you enabled \nsave_timeseries=true\n, then the solver also includes a time-course of the solution captured at every \ntimeseries_steps\n steps.\n\n\nThe solution type has a lot of built in functionality to help analysis. Plotting functionality is provided for each solution type. To plot the solution, simply use\n\n\nplot(sol)\n\n\n\n\nThe plotting function is implemented as a recipe to Plots.jl and as such receives all of the features of a Plots.jl plot.\n\n\nAnother feature is the \nConvergenceSimulation\ns. One can automatically have DifferentialEquations.jl perform the error analysis by passing a \nConvergenceSimulation\n a vector of solutions, or using one of the provided \ntest_convergence\n functions. These will give order of convergence estimates and provide plotting functionality. This requires that the true solution was provided in the problem definition.\n\n\n\n\nSolution Types\n\n\n#\n\n\nDifferentialEquations.FEMSolution\n \n \nType\n.\n\n\nFEMSolution\n\n\nHolds the data for the solution to a finite element problem.\n\n\nFields\n\n\n\n\nfem_mesh::FEMmesh\n: The finite element mesh the problem was solved on.\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueknown::Bool\n: Boolean flag for if the true solution is given.\n\n\nu_analytic::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\nappxTrue::Bool\n: Boolean flag for if u_analytic was an approximation.\n\n\ntimeseries\n::AbstractArrayOrVoid\n: u over time. Only saved if\nsave_timeseries=true`\n\n\n\n\nis specified in the solver. * \nt::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \nprob::DEProblem\n: Holds the problem object used to define the problem. * \nsave_timeseries::Bool\n: True if solver saved the extra timepoints.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nFEMSolution\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nu\n::\nAbstractArray\n,\n\n    \nprob\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:40\n\n\n\n\n\n    \nFEMSolution\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nu\n::\nAbstractArray\n,\n\n    \ntimeseries\n,\n\n    \nt\n,\n\n    \nprob\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:43\n\n\n\n\n\n    \nFEMSolution\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nu\n,\n\n    \nu_analytic\n,\n\n    \nsol\n,\n\n    \nDu\n,\n\n    \ntimeSeries\n,\n\n    \nt\n,\n\n    \nprob\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:34\n\n\n\n\n\n    \nFEMSolution\n(\n\n    \nfem_mesh\n,\n\n    \nu\n,\n\n    \nu_analytic\n,\n\n    \nsol\n,\n\n    \nDu\n,\n\n    \nprob\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:38\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.DESolution\n \n \nType\n.\n\n\nPdeSolution: Wrapper for the objects obtained from a solver\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.SDESolution\n \n \nType\n.\n\n\nSDESolution\n\n\nHolds the data for the solution to a SDE problem.\n\n\nFields\n\n\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueknown::Bool\n: Boolean flag for if the true solution is given.\n\n\nu_analytic::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\ntimeseries\n::AbstractArrayOrVoid\n: u over time. Only saved if\nsave_timeseries=true`\n\n\n\n\nis specified in the solver. * \nt::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \nWs\n: All of the W's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \ntimeseries_analytic\n: If \nsave_timeseries=true\n, saves the solution at each save point. * \nprob::DEProblem\n: Holds the problem object used to define the problem. * \nsave_timeseries::Bool\n: True if solver saved the extra timepoints. * \nappxTrue::Bool\n: Boolean flag for if u_analytic was an approximation.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nSDESolution\n(\nu\n::\nUnion{AbstractArray,Number}\n)\n\n    defined at\n    \nsrc/general/solutions.jl:85\n\n\n\n\n\n    \nSDESolution\n(\na\n)\n\n    defined at\n    \nsrc/general/solutions.jl:99\n\n\n\n\n\n    \nSDESolution\n(\nu\n, \nu_analytic\n)\n\n    defined at\n    \nsrc/general/solutions.jl:90\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.ODESolution\n \n \nType\n.\n\n\nODESolution\n\n\nHolds the data for the solution to an ODE problem.\n\n\nFields\n\n\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueknown::Bool\n: Boolean flag for if the true solution is given.\n\n\nu_analytic::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\ntimeseries\n::AbstractArrayOrVoid\n: u over time. Only saved if\nsave_timeseries=true`\n\n\n\n\nis specified in the solver. * \nt::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nsave_timeseries=true\n is specified in the solver. * \ntimeseries_analytic\n: If \nsave_timeseries=true\n, saves the solution at each timestep. * \nprob::DEProblem\n: Holds the problem object used to define the problem. * \nsave_timeseries::Bool\n: True if solver saved the extra timepoints. * \nappxTrue::Bool\n: Boolean flag for if u_analytic was an approximation.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nODESolution\n(\nu\n)\n\n    defined at\n    \nsrc/general/solutions.jl:134\n\n\n\n\n\n    \nODESolution\n(\nu\n, \nu_analytic\n)\n\n    defined at\n    \nsrc/general/solutions.jl:139\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.StokesSolution\n \n \nType\n.\n\n\nStokesSolution\n\n\nHolds the data for the solution to a Stokes problem.\n\n\nFields\n\n\n\n\nu\n\n\nv\n\n\np\n\n\nu_analytic\n\n\nvTrue\n\n\npTrue\n\n\nmesh\n\n\ntrueknown\n\n\nerrors\n\n\nconverrors\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nStokesSolution\n(\n\n    \nu\n,\n\n    \nv\n,\n\n    \np\n,\n\n    \nu_analytic\n,\n\n    \nvTrue\n,\n\n    \npTrue\n,\n\n    \nmesh\n,\n\n    \ntrueknown\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:179\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.appxTrue!\n \n \nFunction\n.\n\n\nappxTrue!(res,res2)\n\n\nAdds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nappxTrue!\n(\n\n    \nres\n::\nDifferentialEquations.FEMSolution\n,\n\n    \nres2\n::\nDifferentialEquations.FEMSolution\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:191\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.FEMSolutionTS\n \n \nFunction\n.\n\n\nS = FEMSolutionTS(timeseries::GrowableArray,numvars::Int) S[i][j] =\n Variable i at time j.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nFEMSolutionTS\n(\n\n    \ntimeseries\n::\nGrowableArrays.GrowableArray\n,\n\n    \nnumvars\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/general/solutions.jl:201", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#the-solution-type", 
            "text": "Each solver has an appropriate solution type. The solution type holds all of the information about the problem which was solved an its solution. If you enabled  save_timeseries=true , then the solver also includes a time-course of the solution captured at every  timeseries_steps  steps.  The solution type has a lot of built in functionality to help analysis. Plotting functionality is provided for each solution type. To plot the solution, simply use  plot(sol)  The plotting function is implemented as a recipe to Plots.jl and as such receives all of the features of a Plots.jl plot.  Another feature is the  ConvergenceSimulation s. One can automatically have DifferentialEquations.jl perform the error analysis by passing a  ConvergenceSimulation  a vector of solutions, or using one of the provided  test_convergence  functions. These will give order of convergence estimates and provide plotting functionality. This requires that the true solution was provided in the problem definition.", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#solution-types", 
            "text": "#  DifferentialEquations.FEMSolution     Type .  FEMSolution  Holds the data for the solution to a finite element problem.  Fields   fem_mesh::FEMmesh : The finite element mesh the problem was solved on.  u::Array{Float64} : The solution (at the final timepoint)  trueknown::Bool : Boolean flag for if the true solution is given.  u_analytic::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  appxTrue::Bool : Boolean flag for if u_analytic was an approximation.  timeseries ::AbstractArrayOrVoid : u over time. Only saved if save_timeseries=true`   is specified in the solver. *  t::AbstractArrayOrVoid : All the t's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  prob::DEProblem : Holds the problem object used to define the problem. *  save_timeseries::Bool : True if solver saved the extra timepoints.  source  Methods   \n     FEMSolution ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      u :: AbstractArray ,      prob  ) \n    defined at\n     src/general/solutions.jl:40   \n     FEMSolution ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      u :: AbstractArray ,      timeseries ,      t ,      prob  ) \n    defined at\n     src/general/solutions.jl:43   \n     FEMSolution ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      u ,      u_analytic ,      sol ,      Du ,      timeSeries ,      t ,      prob  ) \n    defined at\n     src/general/solutions.jl:34   \n     FEMSolution ( \n     fem_mesh ,      u ,      u_analytic ,      sol ,      Du ,      prob  ) \n    defined at\n     src/general/solutions.jl:38    Hiding 1 method defined outside of this package.  #  DifferentialEquations.DESolution     Type .  PdeSolution: Wrapper for the objects obtained from a solver  source  #  DifferentialEquations.SDESolution     Type .  SDESolution  Holds the data for the solution to a SDE problem.  Fields   u::Array{Float64} : The solution (at the final timepoint)  trueknown::Bool : Boolean flag for if the true solution is given.  u_analytic::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  timeseries ::AbstractArrayOrVoid : u over time. Only saved if save_timeseries=true`   is specified in the solver. *  t::AbstractArrayOrVoid : All the t's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  Ws : All of the W's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  timeseries_analytic : If  save_timeseries=true , saves the solution at each save point. *  prob::DEProblem : Holds the problem object used to define the problem. *  save_timeseries::Bool : True if solver saved the extra timepoints. *  appxTrue::Bool : Boolean flag for if u_analytic was an approximation.  source  Methods   \n     SDESolution ( u :: Union{AbstractArray,Number} ) \n    defined at\n     src/general/solutions.jl:85   \n     SDESolution ( a ) \n    defined at\n     src/general/solutions.jl:99   \n     SDESolution ( u ,  u_analytic ) \n    defined at\n     src/general/solutions.jl:90    Hiding 1 method defined outside of this package.  #  DifferentialEquations.ODESolution     Type .  ODESolution  Holds the data for the solution to an ODE problem.  Fields   u::Array{Float64} : The solution (at the final timepoint)  trueknown::Bool : Boolean flag for if the true solution is given.  u_analytic::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  timeseries ::AbstractArrayOrVoid : u over time. Only saved if save_timeseries=true`   is specified in the solver. *  t::AbstractArrayOrVoid : All the t's in the solution. Only saved if  save_timeseries=true  is specified in the solver. *  timeseries_analytic : If  save_timeseries=true , saves the solution at each timestep. *  prob::DEProblem : Holds the problem object used to define the problem. *  save_timeseries::Bool : True if solver saved the extra timepoints. *  appxTrue::Bool : Boolean flag for if u_analytic was an approximation.  source  Methods   \n     ODESolution ( u ) \n    defined at\n     src/general/solutions.jl:134   \n     ODESolution ( u ,  u_analytic ) \n    defined at\n     src/general/solutions.jl:139    Hiding 1 method defined outside of this package.  #  DifferentialEquations.StokesSolution     Type .  StokesSolution  Holds the data for the solution to a Stokes problem.  Fields   u  v  p  u_analytic  vTrue  pTrue  mesh  trueknown  errors  converrors   source  Methods   \n     StokesSolution ( \n     u ,      v ,      p ,      u_analytic ,      vTrue ,      pTrue ,      mesh ,      trueknown  ) \n    defined at\n     src/general/solutions.jl:179    Hiding 1 method defined outside of this package.", 
            "title": "Solution Types"
        }, 
        {
            "location": "/man/solution/#related-functions", 
            "text": "#  DifferentialEquations.appxTrue!     Function .  appxTrue!(res,res2)  Adds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution  source  Methods   \n     appxTrue! ( \n     res :: DifferentialEquations.FEMSolution ,      res2 :: DifferentialEquations.FEMSolution  ) \n    defined at\n     src/general/solutions.jl:191    #  DifferentialEquations.FEMSolutionTS     Function .  S = FEMSolutionTS(timeseries::GrowableArray,numvars::Int) S[i][j] =  Variable i at time j.  source  Methods   \n     FEMSolutionTS ( \n     timeseries :: GrowableArrays.GrowableArray ,      numvars :: Int64  ) \n    defined at\n     src/general/solutions.jl:201", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/plot/", 
            "text": "Plot Functions\n\n\n\n\nStandard Plots\n\n\nPlotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the \nplot(type)\n and the plotter will generate appropriate plots. If \nsave_timeseries\n was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using \nall of the keyword arguments provided by Plots.jl\n. Please see \nPlots.jl's documentation\n for more information.\n\n\nA few extra arguments are provided addition to the Plots.jl keyword arguments. They are as follows:\n\n\n\n\nplot_analytic: Specifies whether the true solution (if known) should be plotted alongside the numerically approximated solution. Default is false.\n\n\nfilename: Specifies the filename to save an animation. Only applies to the \nanimate\n function.\n\n\nfps: Determines the fps in an animation. Only applies to the \nanimate\n function.\n\n\n\n\n\n\nExtra Plot Functions\n\n\n#\n\n\nDifferentialEquations.animate\n \n \nFunction\n.\n\n\nanimate(sol::FEMSolution)\n\n\nPlots an animation of the solution. Requires \nsave_timeseries=true\n was enabled in the solver.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nanimate\n(\nsol\n::\nDifferentialEquations.FEMSolution\n)\n\n    defined at\n    \nsrc/general/plotrecipes.jl:7", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#plot-functions", 
            "text": "", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#standard-plots", 
            "text": "Plotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the  plot(type)  and the plotter will generate appropriate plots. If  save_timeseries  was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using  all of the keyword arguments provided by Plots.jl . Please see  Plots.jl's documentation  for more information.  A few extra arguments are provided addition to the Plots.jl keyword arguments. They are as follows:   plot_analytic: Specifies whether the true solution (if known) should be plotted alongside the numerically approximated solution. Default is false.  filename: Specifies the filename to save an animation. Only applies to the  animate  function.  fps: Determines the fps in an animation. Only applies to the  animate  function.", 
            "title": "Standard Plots"
        }, 
        {
            "location": "/man/plot/#extra-plot-functions", 
            "text": "#  DifferentialEquations.animate     Function .  animate(sol::FEMSolution)  Plots an animation of the solution. Requires  save_timeseries=true  was enabled in the solver.  source  Methods   \n     animate ( sol :: DifferentialEquations.FEMSolution ) \n    defined at\n     src/general/plotrecipes.jl:7", 
            "title": "Extra Plot Functions"
        }, 
        {
            "location": "/man/convergence/", 
            "text": "Convergence Simulations\n\n\nThe convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.\n\n\nConvergenceSimulation\ns can either be created by passing the constructor the appropriate solution array or by using one of the provided \ntest_convergence\n functions.\n\n\n\n\nThe ConvergenceSimulation Type\n\n\n#\n\n\nDifferentialEquations.ConvergenceSimulation\n \n \nType\n.\n\n\nConvergenceSimulation\n\n\nA type which holds the data from a convergence simulation.\n\n\nFields\n\n\n\n\nsolutions::Array{DESolution}\n: Holds all the PdeSolutions.\n\n\nerrors\n: Dictionary of the error calculations. Can contain: * \nh1Errors\n: Vector of the H1 errors. * \nl2Errors\n: Vector of the L2 errors. * \nmaxErrors\n: Vector of the nodal maximum errors. * \nnode2Errors\n: Vector of the nodal l2 errors.\n\n\nN\n: The number of simulations.\n\n\nauxdata\n: Auxillary data of the convergence simluation. Entries can include: * \n\u0394ts\n: The \u0394t's in the simulations. * \n\u0394xs\n: The \u0394x's in the simulations. * \n\u03bcs\n: The CFL \u03bc's in the simulations. * \n\u03bds\n: The CFL \u03bd's in the simulations.\n\n\n\ud835\udcaaest\n: Dictionary of order estimates. Can contain: * \nConvEst_h1\n: The H1 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1) * \nConvEst_l2\n: The L2 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2) * \nConvEst_max\n: The nodal maximum error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max) * \nConvEst_node2\n: The nodal l2 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)\n\n\nconvergence_axis\n: The axis along which convergence is calculated. For example, if we calculate the \u0394t convergence, convergence_axis is the \u0394ts used in the calculation.\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nConvergenceSimulation\n(\n\n    \nsolutions\n::\nArray{DifferentialEquations.DESolution,N\n<\n:Any}\n,\n\n    \nconvergence_axis\n\n\n)\n\n    defined at\n    \nsrc/general/convergence.jl:44\n\n\n\n\n\n    \nConvergenceSimulation\n(\n\n    \nsolutions\n::\nArray{DifferentialEquations.SDESolution,N\n<\n:Any}\n,\n\n    \nconvergence_axis\n\n\n)\n\n    defined at\n    \nsrc/general/convergence.jl:61\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nPlot Functions\n\n\nThe plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:\n\n\nplot(sim::ConvergenceSimulation)\n\n\n\n\nAll of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.\n\n\n\n\nRelated Functions\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.conv_ests\n \n \nFunction\n.\n\n\nconv_ests(error::AbstractArray{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconv_ests\n(\nerror\n::\nAbstractArray{Float64,N\n<\n:Any}\n)\n\n    defined at\n    \nsrc/general/convergence.jl:184\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.calc\ud835\udcaaestimates\n \n \nFunction\n.\n\n\nconv_ests(error::Vector{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncalc\ud835\udcaaestimates\n(\nerror\n::\nPair\n)\n\n    defined at\n    \nsrc/general/convergence.jl:163\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.test_convergence\n \n \nFunction\n.\n\n\ntest_convergence(\u0394ts::AbstractArray,prob::SDEProblem)\n\n\nTests the strong order time convergence of the given algorithm on the given problem solved over the given \u0394ts.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Default is 1\n\n\nnumMonte\n: The number of simulations for each \u0394t. Default is 10000.\n\n\nsave_timeseries\n: Denotes whether to save at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes the steps to save at if \nsave_timeseries=true\n. Default is 1\n\n\nalg\n: The algorithm to test. Defaults to \"EM\".\n\n\n\n\nsource\n\n\ntest_convergence(\u0394ts::AbstractArray,prob::ODEProblem)\n\n\nTests the order of the time convergence of the given algorithm on the given problem solved over the given \u0394ts.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Default is 1\n\n\nsave_timeseries\n: Denotes whether to save at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes the steps to save at if \nsave_timeseries=true\n. Default is 1\n\n\nalg\n: The algorithm to test. Defaults to \"Euler\".\n\n\ntableau\n: The tableau used for generic methods. Defaults to ODE_DEFAULT_TABLEAU.\n\n\n\n\nsource\n\n\ntest_convergence(\u0394ts::AbstractArray,\u0394xs::AbstractArray,prob::HeatProblem,convergence_axis)\n\n\nTests the convergence of the solver algorithm on the given Heat problem with the \u0394ts and \u0394xs as given. Uses the square mesh [0,1]x[0,1]. The convergence axis is the axis along which convergence is calculated. For example, when testing \u0394t convergence, \nconvergence_axis = \u0394ts\n.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Defaults to 1\n\n\nalg\n: The algorithm to test. Default is \"Euler\".\n\n\n\n\nsource\n\n\ntest_convergence(\u0394xs::AbstractArray,prob::PoissonProblem)\n\n\nTests the convergence of the solver algorithm on the given Poisson problem with \u0394xs as given. Uses the square mesh [0,1]x[0,1].\n\n\nKeyword Arguments\n\n\n\n\nsolver\n: Which solver to use. Default is \"Direct\".\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ntest_convergence\n(\n\n    \n\u0394ts\n::\nAbstractArray\n,\n\n    \nprob\n::\nDifferentialEquations.SDEProblem\n\n\n)\n\n    defined at\n    \nsrc/general/convergence.jl:79\n\n\n\n\n\n    \ntest_convergence\n(\n\n    \n\u0394ts\n::\nAbstractArray\n,\n\n    \nprob\n::\nDifferentialEquations.ODEProblem\n\n\n)\n\n    defined at\n    \nsrc/general/convergence.jl:104\n\n\n\n\n\n    \ntest_convergence\n(\n\n    \n\u0394ts\n::\nAbstractArray\n,\n\n    \n\u0394xs\n::\nAbstractArray\n,\n\n    \nprob\n::\nDifferentialEquations.HeatProblem\n,\n\n    \nconvergence_axis\n\n\n)\n\n    defined at\n    \nsrc/general/convergence.jl:124\n\n\n\n\n\n    \ntest_convergence\n(\n\n    \n\u0394xs\n::\nAbstractArray\n,\n\n    \nprob\n::\nDifferentialEquations.PoissonProblem\n\n\n)\n\n    defined at\n    \nsrc/general/convergence.jl:145", 
            "title": "Convergence Simuations"
        }, 
        {
            "location": "/man/convergence/#convergence-simulations", 
            "text": "The convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.  ConvergenceSimulation s can either be created by passing the constructor the appropriate solution array or by using one of the provided  test_convergence  functions.", 
            "title": "Convergence Simulations"
        }, 
        {
            "location": "/man/convergence/#the-convergencesimulation-type", 
            "text": "#  DifferentialEquations.ConvergenceSimulation     Type .  ConvergenceSimulation  A type which holds the data from a convergence simulation.  Fields   solutions::Array{DESolution} : Holds all the PdeSolutions.  errors : Dictionary of the error calculations. Can contain: *  h1Errors : Vector of the H1 errors. *  l2Errors : Vector of the L2 errors. *  maxErrors : Vector of the nodal maximum errors. *  node2Errors : Vector of the nodal l2 errors.  N : The number of simulations.  auxdata : Auxillary data of the convergence simluation. Entries can include: *  \u0394ts : The \u0394t's in the simulations. *  \u0394xs : The \u0394x's in the simulations. *  \u03bcs : The CFL \u03bc's in the simulations. *  \u03bds : The CFL \u03bd's in the simulations.  \ud835\udcaaest : Dictionary of order estimates. Can contain: *  ConvEst_h1 : The H1 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1) *  ConvEst_l2 : The L2 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2) *  ConvEst_max : The nodal maximum error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max) *  ConvEst_node2 : The nodal l2 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)  convergence_axis : The axis along which convergence is calculated. For example, if we calculate the \u0394t convergence, convergence_axis is the \u0394ts used in the calculation.   source  Methods   \n     ConvergenceSimulation ( \n     solutions :: Array{DifferentialEquations.DESolution,N < :Any} ,      convergence_axis  ) \n    defined at\n     src/general/convergence.jl:44   \n     ConvergenceSimulation ( \n     solutions :: Array{DifferentialEquations.SDESolution,N < :Any} ,      convergence_axis  ) \n    defined at\n     src/general/convergence.jl:61    Hiding 1 method defined outside of this package.", 
            "title": "The ConvergenceSimulation Type"
        }, 
        {
            "location": "/man/convergence/#plot-functions", 
            "text": "The plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:  plot(sim::ConvergenceSimulation)  All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/convergence/#related-functions", 
            "text": "#  Base.length     Method .  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation  source  #  DifferentialEquations.conv_ests     Function .  conv_ests(error::AbstractArray{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates  source  Methods   \n     conv_ests ( error :: AbstractArray{Float64,N < :Any} ) \n    defined at\n     src/general/convergence.jl:184    #  DifferentialEquations.calc\ud835\udcaaestimates     Function .  conv_ests(error::Vector{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates  source  Methods   \n     calc\ud835\udcaaestimates ( error :: Pair ) \n    defined at\n     src/general/convergence.jl:163    #  DifferentialEquations.test_convergence     Function .  test_convergence(\u0394ts::AbstractArray,prob::SDEProblem)  Tests the strong order time convergence of the given algorithm on the given problem solved over the given \u0394ts.  Keyword Arguments   T : The final time. Default is 1  numMonte : The number of simulations for each \u0394t. Default is 10000.  save_timeseries : Denotes whether to save at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes the steps to save at if  save_timeseries=true . Default is 1  alg : The algorithm to test. Defaults to \"EM\".   source  test_convergence(\u0394ts::AbstractArray,prob::ODEProblem)  Tests the order of the time convergence of the given algorithm on the given problem solved over the given \u0394ts.  Keyword Arguments   T : The final time. Default is 1  save_timeseries : Denotes whether to save at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes the steps to save at if  save_timeseries=true . Default is 1  alg : The algorithm to test. Defaults to \"Euler\".  tableau : The tableau used for generic methods. Defaults to ODE_DEFAULT_TABLEAU.   source  test_convergence(\u0394ts::AbstractArray,\u0394xs::AbstractArray,prob::HeatProblem,convergence_axis)  Tests the convergence of the solver algorithm on the given Heat problem with the \u0394ts and \u0394xs as given. Uses the square mesh [0,1]x[0,1]. The convergence axis is the axis along which convergence is calculated. For example, when testing \u0394t convergence,  convergence_axis = \u0394ts .  Keyword Arguments   T : The final time. Defaults to 1  alg : The algorithm to test. Default is \"Euler\".   source  test_convergence(\u0394xs::AbstractArray,prob::PoissonProblem)  Tests the convergence of the solver algorithm on the given Poisson problem with \u0394xs as given. Uses the square mesh [0,1]x[0,1].  Keyword Arguments   solver : Which solver to use. Default is \"Direct\".   source  Methods   \n     test_convergence ( \n     \u0394ts :: AbstractArray ,      prob :: DifferentialEquations.SDEProblem  ) \n    defined at\n     src/general/convergence.jl:79   \n     test_convergence ( \n     \u0394ts :: AbstractArray ,      prob :: DifferentialEquations.ODEProblem  ) \n    defined at\n     src/general/convergence.jl:104   \n     test_convergence ( \n     \u0394ts :: AbstractArray ,      \u0394xs :: AbstractArray ,      prob :: DifferentialEquations.HeatProblem ,      convergence_axis  ) \n    defined at\n     src/general/convergence.jl:124   \n     test_convergence ( \n     \u0394xs :: AbstractArray ,      prob :: DifferentialEquations.PoissonProblem  ) \n    defined at\n     src/general/convergence.jl:145", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/conditional_dependencies/", 
            "text": "Conditional Dependencies\n\n\nDifferentialEquations.jl is conditionally dependent on some packages which may not be required for all users. The upside is that you can run DifferentialEquations.jl without installing these packages. However, the downside is that you will have to do the installation yourself (normal dependencies do a silent install). Luckily DifferentialEquations.jl warns you about missing dependencies when calling a method which requires one. This part of the manual will detail how to see if you're missing a conditional dependency and how to alleviate the issue.\n\n\n\n\nThe Conditional Dependency Notification\n\n\nWhen a conditional dependency is required, DifferentialEquations.jl will import the package the first time the method is called. When this happens, you will receive a notification as follows:\n\n\n[DifferentialEquations.jl] Initializing backend: PkgName\n\n\n\n\nwhere PkgName is the name of the package it is importing. DifferentialEquations.jl will then run a standard startup procedure on this package. If it fails, you will receive the message\n\n\nWARNING: Couldn't initialize PkgName.  (might need to install it?)\n\n\n\n\nMost likely the issue is that you need to install the package. Go to the package's Github repository for information on installing the package, and then come back to try again. If that does not work, you may need the latest version of the package by checking out master:\n\n\nPkg.checkout(\nPkgName\n)\n\n\n\n\nIf all else fails, please ask for help on \nvia the repository Gitter\n.\n\n\n\n\nWhat Methods Require Conditional Dependencies?\n\n\nThat's a good question! The implicit algorithms implemented in DifferentialEquations.jl require \nNLsolve.jl\n, and can optionally use \nForwardDiff.jl\n for increased performance. Also, the \nload\n function for the premade meshes requires \nJLD.jl\n.\n\n\nLastly, there is a special conditional dependency for \nJuno\n. If you are using Juno, then the progress bar functionality is works. If you're not using Juno, then it won't do anything.\n\n\nThe other conditional dependencies are external solvers wrapped by DifferentialEquations.jl Currently these include:\n\n\n\n\nODE.jl\n\n\nODEInterface.jl\n\n\n\n\n\n\nInstallation Instructions\n\n\nFor most of the conditional dependencies, the installation instructions are standard. However, for some of the newest features, special instructions may be required. The best way to stay up-to-date on this information is to checkout the following resources:\n\n\n\n\nThe packages which are conditional dependencies and use a standard installation can be found in the \n/test/REQUIRE\n file.\n\n\nAny special installation instructions are handled via \nthe ci_setup.jl file\n.\n\n\n\n\nThe current special installation instructions are as follows:\n\n\n\n\nODE.jl.\n\n\nThe wrapper currently only works on the development branch of ODE.jl at JuliaODE/ODE.jl. To install this version of ODE.jl, use the following commands:\n\n\nPkg.clone(\nhttps://github.com/JuliaODE/ODE.jl\n)\nPkg.checkout(\nODE\n,\ndev\n)", 
            "title": "Conditional Dependencies"
        }, 
        {
            "location": "/man/conditional_dependencies/#conditional-dependencies", 
            "text": "DifferentialEquations.jl is conditionally dependent on some packages which may not be required for all users. The upside is that you can run DifferentialEquations.jl without installing these packages. However, the downside is that you will have to do the installation yourself (normal dependencies do a silent install). Luckily DifferentialEquations.jl warns you about missing dependencies when calling a method which requires one. This part of the manual will detail how to see if you're missing a conditional dependency and how to alleviate the issue.", 
            "title": "Conditional Dependencies"
        }, 
        {
            "location": "/man/conditional_dependencies/#the-conditional-dependency-notification", 
            "text": "When a conditional dependency is required, DifferentialEquations.jl will import the package the first time the method is called. When this happens, you will receive a notification as follows:  [DifferentialEquations.jl] Initializing backend: PkgName  where PkgName is the name of the package it is importing. DifferentialEquations.jl will then run a standard startup procedure on this package. If it fails, you will receive the message  WARNING: Couldn't initialize PkgName.  (might need to install it?)  Most likely the issue is that you need to install the package. Go to the package's Github repository for information on installing the package, and then come back to try again. If that does not work, you may need the latest version of the package by checking out master:  Pkg.checkout( PkgName )  If all else fails, please ask for help on  via the repository Gitter .", 
            "title": "The Conditional Dependency Notification"
        }, 
        {
            "location": "/man/conditional_dependencies/#what-methods-require-conditional-dependencies", 
            "text": "That's a good question! The implicit algorithms implemented in DifferentialEquations.jl require  NLsolve.jl , and can optionally use  ForwardDiff.jl  for increased performance. Also, the  load  function for the premade meshes requires  JLD.jl .  Lastly, there is a special conditional dependency for  Juno . If you are using Juno, then the progress bar functionality is works. If you're not using Juno, then it won't do anything.  The other conditional dependencies are external solvers wrapped by DifferentialEquations.jl Currently these include:   ODE.jl  ODEInterface.jl", 
            "title": "What Methods Require Conditional Dependencies?"
        }, 
        {
            "location": "/man/conditional_dependencies/#installation-instructions", 
            "text": "For most of the conditional dependencies, the installation instructions are standard. However, for some of the newest features, special instructions may be required. The best way to stay up-to-date on this information is to checkout the following resources:   The packages which are conditional dependencies and use a standard installation can be found in the  /test/REQUIRE  file.  Any special installation instructions are handled via  the ci_setup.jl file .   The current special installation instructions are as follows:", 
            "title": "Installation Instructions"
        }, 
        {
            "location": "/man/conditional_dependencies/#odejl", 
            "text": "The wrapper currently only works on the development branch of ODE.jl at JuliaODE/ODE.jl. To install this version of ODE.jl, use the following commands:  Pkg.clone( https://github.com/JuliaODE/ODE.jl )\nPkg.checkout( ODE , dev )", 
            "title": "ODE.jl."
        }, 
        {
            "location": "/internals/contributors_guide/", 
            "text": "Contributor's Guide\n\n\nSo you're looking to help out DifferentialEquations.jl? We'd be happy to have your help. It is recommended you first discuss with some of the developers \non the Gitter channel\n to make sure that you're up-to-date with current developments.\n\n\n\n\nDeveloping New Solver Algorithms\n\n\nThe easiest way to get started would be to add new solver algorithms. This is a pretty simple task as there are tools which put you right into the \"hot loop\". For example, take a look at the ODE solver code. The mode \nsolve(::ODEProblem,::AbstractArray)\n is glue code to a bunch of solver algorithms. The algorithms which are coded in DifferentialEquations.jl can be found in ode_integrators.jl. For example, take a look at the Midpoint method's implementation:\n\n\nfunction ode_midpoint(f::Function,u::AbstractArray,t,\u0394t,T,iter,\n                      maxiters,timeseries,ts,timeseries_steps,save_timeseries,adaptive,progressbar)\n  half\u0394t = \u0394t/2\n  utilde = similar(u)\n  while t \n T\n    @ode_loopheader\n    utilde[:] = u+half\u0394t.*f(u,t)\n    u = u + \u0394t.*f(utilde,t+half\u0394t)\n    @ode_loopfooter\n  end\n  return u,t,timeseries,ts\nend\n\n\n\n\nThe parts in the signature are the items you have available. Most are self-explanatory (they are from the ODE problem). The extra are for parts of the header and footer for exiting at max iterations, and plugging into the Juno progressbar. These are done in the \n@ode_loopheader\n and \n@ode_loopfooter\n macros, which are defined using the \n@def\n macro (they essentially copy-paste the code from the line which says \n@def ode_loopheader begin ... end\n). Note that the loopfooter code takes care of the code for doing the adaptive timestepping. All that is required for the adaptivity is that the algorithm computes an error estimate \nEEst\n each time, and that the algorithm's symbol is added to the dictionary \nODE_DIFFERENTIALEQUATIONSJL_ADAPTIVEALGS\n in \node_constants.jl\n. If implicit solving is needed (via NLsolve), add the algorithm's symbol to \nDIFFERENTIALEQUATIONSJL_IMPLICITALGS\n and the conditional dependency will be supplied. Note that you may need more function arguments. Use another method as a template.\n\n\nWhen the solver is completed, add a call to the solver in the glue code \nsolve(::ODEProblem,::AbstractArray)\n (you will see all the others), add the symbol for the algorithm to \nDIFFERENTIALEQUATIONSJL_ALGORITHMS\n, and the order to \nDIFFERENTIALEQUATIONSJL_ORDERS\n. It's that quick! Lastly, add your method to the convergence tests in the appropriate /test file.  Feel free to implement any interesting or educational algorithm: they don't have to be the fastest and it is always is useful to have such algorithms (like Simpson's method) available for demonstration purposes.\n\n\nAdding algorithms to the other problems is very similar.\n\n\n\n\nAdding Conditional Dependencies\n\n\nIf your algorithm requires a conditional dependency (a package, but not one that everyone who uses DifferentialEquations.jl would need), you can add them as follows. Before the loop, add the line \ninitialize_backend(:PkgName)\n where \n:PkgName\n is the same name as the package you wish to use. Then, in \ngeneral/backends.jl\n add a dispatch to \ninit_package\n. A common one would be:\n\n\ninit_package(b::backend{:PkgName}) = @eval begin\n      import PkgName\n      export PkgName\n    end\n\n\n\n\nNow inside your method you can use any function from the package via PkgName.function. The first time it is used it import the package (or tell the user to install it).\n\n\n\n\nDeveloping A New Problem\n\n\nTo develop a new problem, you need to make a new \nDEProblem\n and a new \nDESolution\n. The \nDEProblem\n type should hold all of the mathematical information about the problem, and the \nDESolution\n should hold all of the information for the solution. Then all that is required is to define a \nsolve(::DEProblem,*Extra Mesh Things*;kwargs)\n which takes in the problem and returns a solution. To add plotting functionality, add a plot recipe for the solution type to \n/general/plotrecipes\n. For testing that the algorithm works, add a dispatch for \ntest_convergence\n which makes a \nConvergenceSimulation\n type. This type already has a plot recipe, so plotting functionality will already be embedded. This requires that your problem can take in a true solution, and has a field \nerrors\n which is a dictionary of symbols for the different error estimates (L2,L infinity, etc.)\n\n\n\n\nOther Help\n\n\nThere's always more to be. Improved plot recipes and new series recipes are always nice to add more default plots. It is always helpful to have benchmarks between different algorithms to see \"which is best\". Adding examples IJulia notebooks to \n/examples/\n is a good way to share knowledge about DifferentialEquations.jl. Also, please feel free to comb through the solvers and look for ways to make them more efficient. Lastly, the documentation could always use improvements. If you have any questions on how to help, just ask them in the Gitter!", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/internals/contributors_guide/#contributors-guide", 
            "text": "So you're looking to help out DifferentialEquations.jl? We'd be happy to have your help. It is recommended you first discuss with some of the developers  on the Gitter channel  to make sure that you're up-to-date with current developments.", 
            "title": "Contributor's Guide"
        }, 
        {
            "location": "/internals/contributors_guide/#developing-new-solver-algorithms", 
            "text": "The easiest way to get started would be to add new solver algorithms. This is a pretty simple task as there are tools which put you right into the \"hot loop\". For example, take a look at the ODE solver code. The mode  solve(::ODEProblem,::AbstractArray)  is glue code to a bunch of solver algorithms. The algorithms which are coded in DifferentialEquations.jl can be found in ode_integrators.jl. For example, take a look at the Midpoint method's implementation:  function ode_midpoint(f::Function,u::AbstractArray,t,\u0394t,T,iter,\n                      maxiters,timeseries,ts,timeseries_steps,save_timeseries,adaptive,progressbar)\n  half\u0394t = \u0394t/2\n  utilde = similar(u)\n  while t   T\n    @ode_loopheader\n    utilde[:] = u+half\u0394t.*f(u,t)\n    u = u + \u0394t.*f(utilde,t+half\u0394t)\n    @ode_loopfooter\n  end\n  return u,t,timeseries,ts\nend  The parts in the signature are the items you have available. Most are self-explanatory (they are from the ODE problem). The extra are for parts of the header and footer for exiting at max iterations, and plugging into the Juno progressbar. These are done in the  @ode_loopheader  and  @ode_loopfooter  macros, which are defined using the  @def  macro (they essentially copy-paste the code from the line which says  @def ode_loopheader begin ... end ). Note that the loopfooter code takes care of the code for doing the adaptive timestepping. All that is required for the adaptivity is that the algorithm computes an error estimate  EEst  each time, and that the algorithm's symbol is added to the dictionary  ODE_DIFFERENTIALEQUATIONSJL_ADAPTIVEALGS  in  ode_constants.jl . If implicit solving is needed (via NLsolve), add the algorithm's symbol to  DIFFERENTIALEQUATIONSJL_IMPLICITALGS  and the conditional dependency will be supplied. Note that you may need more function arguments. Use another method as a template.  When the solver is completed, add a call to the solver in the glue code  solve(::ODEProblem,::AbstractArray)  (you will see all the others), add the symbol for the algorithm to  DIFFERENTIALEQUATIONSJL_ALGORITHMS , and the order to  DIFFERENTIALEQUATIONSJL_ORDERS . It's that quick! Lastly, add your method to the convergence tests in the appropriate /test file.  Feel free to implement any interesting or educational algorithm: they don't have to be the fastest and it is always is useful to have such algorithms (like Simpson's method) available for demonstration purposes.  Adding algorithms to the other problems is very similar.", 
            "title": "Developing New Solver Algorithms"
        }, 
        {
            "location": "/internals/contributors_guide/#adding-conditional-dependencies", 
            "text": "If your algorithm requires a conditional dependency (a package, but not one that everyone who uses DifferentialEquations.jl would need), you can add them as follows. Before the loop, add the line  initialize_backend(:PkgName)  where  :PkgName  is the same name as the package you wish to use. Then, in  general/backends.jl  add a dispatch to  init_package . A common one would be:  init_package(b::backend{:PkgName}) = @eval begin\n      import PkgName\n      export PkgName\n    end  Now inside your method you can use any function from the package via PkgName.function. The first time it is used it import the package (or tell the user to install it).", 
            "title": "Adding Conditional Dependencies"
        }, 
        {
            "location": "/internals/contributors_guide/#developing-a-new-problem", 
            "text": "To develop a new problem, you need to make a new  DEProblem  and a new  DESolution . The  DEProblem  type should hold all of the mathematical information about the problem, and the  DESolution  should hold all of the information for the solution. Then all that is required is to define a  solve(::DEProblem,*Extra Mesh Things*;kwargs)  which takes in the problem and returns a solution. To add plotting functionality, add a plot recipe for the solution type to  /general/plotrecipes . For testing that the algorithm works, add a dispatch for  test_convergence  which makes a  ConvergenceSimulation  type. This type already has a plot recipe, so plotting functionality will already be embedded. This requires that your problem can take in a true solution, and has a field  errors  which is a dictionary of symbols for the different error estimates (L2,L infinity, etc.)", 
            "title": "Developing A New Problem"
        }, 
        {
            "location": "/internals/contributors_guide/#other-help", 
            "text": "There's always more to be. Improved plot recipes and new series recipes are always nice to add more default plots. It is always helpful to have benchmarks between different algorithms to see \"which is best\". Adding examples IJulia notebooks to  /examples/  is a good way to share knowledge about DifferentialEquations.jl. Also, please feel free to comb through the solvers and look for ways to make them more efficient. Lastly, the documentation could always use improvements. If you have any questions on how to help, just ask them in the Gitter!", 
            "title": "Other Help"
        }, 
        {
            "location": "/internals/fem_tools/", 
            "text": "Internal Finite Element Tools\n\n\n\n\nGeneral\n\n\n#\n\n\nDifferentialEquations\n \n \nModule\n.\n\n\n\n\nMesh Tools\n\n\n#\n\n\nDifferentialEquations.CFL\u03bd\n \n \nFunction\n.\n\n\nCFL\u03bd(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bd= \u0394t/\u0394x\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nCFL\u03bd\n(\n\u0394t\n, \n\u0394x\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:122\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.CFL\u03bc\n \n \nFunction\n.\n\n\nCFL\u03bc(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nCFL\u03bc\n(\n\u0394t\n, \n\u0394x\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:115\n\n\n\n\n\n\n\n\n\nSolver Tools\n\n\n#\n\n\nDifferentialEquations.\u2207basis\n \n \nFunction\n.\n\n\n\u2207basis(node,elem)\n\n\nReturns the \u2207u of the barycentric basis elements.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \n\u2207basis\n(\nnode\n, \nelem\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:490\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.quadfbasis\n \n \nFunction\n.\n\n\nquadfbasis(f,gD,gN,A,u,node,elem,area,bdnode,mid,N,dirichlet,neumann,islinear,numvars;gNquad\ud835\udcaa=2)\n\n\nPerforms the order 2 quadrature to calculate the vector from the term $\n<f\n,v>$ for linear elements.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nquadfbasis\n(\n\n    \nf\n,\n\n    \ngD\n,\n\n    \ngN\n,\n\n    \nA\n,\n\n    \nu\n,\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \narea\n,\n\n    \nbdnode\n,\n\n    \nmid\n,\n\n    \nN\n,\n\n    \ndirichlet\n,\n\n    \nneumann\n,\n\n    \nislinear\n,\n\n    \nnumvars\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_solve.jl:259\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.quadpts\n \n \nFunction\n.\n\n\nquadpts(\ud835\udcaa)\n\n\nReturns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.\n\n\nReference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nquadpts\n(\n\ud835\udcaa\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:146\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.quadpts1\n \n \nFunction\n.\n\n\nquadpts1(\ud835\udcaa)\n\n\nReferences: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nquadpts1\n(\n\ud835\udcaa\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:265\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.assemblematrix\n \n \nFunction\n.\n\n\nassemblematrix(node,elem;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nsource\n\n\nassemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nassemblematrix\n(\nFEMmesh\n::\nDifferentialEquations.FEMmesh\n)\n\n    defined at\n    \nsrc/fem/fem_assembly.jl:72\n\n\n\n\n\n    \nassemblematrix\n(\nnode\n, \nelem\n)\n\n    defined at\n    \nsrc/fem/fem_assembly.jl:19\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.\u2207u\n \n \nFunction\n.\n\n\n\u2207u(node,elem,u,D\u03bb=[])\n\n\nEstimates \u2207u of u on the mesh (node,elem)\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \n\u2207u\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nu\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:473\n\n\n\n\n\n    \n\u2207u\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nu\n,\n\n    \nD\u03bb\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:473\n\n\n\n\n\n\n\n\n\nError Tools\n\n\n#\n\n\nDifferentialEquations.getH1error\n \n \nFunction\n.\n\n\nfunction getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])\n\n\ngetH1error(fem_mesh::FEMmesh,Du,u)\n\n\nEstimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ngetH1error\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nDu\n,\n\n    \nu\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:518\n\n\n\n\n\n    \ngetH1error\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nDu\n,\n\n    \nuh\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:353\n\n\n\n\n\n    \ngetH1error\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nDu\n,\n\n    \nuh\n,\n\n    \nK\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:353\n\n\n\n\n\n    \ngetH1error\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nDu\n,\n\n    \nuh\n,\n\n    \nK\n,\n\n    \nquad\ud835\udcaa\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:353\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.getL2error\n \n \nFunction\n.\n\n\ngetL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])\n\n\ngetL2error(fem_mesh::FEMmesh,sol,u)\n\n\nEstimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ngetL2error\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nsol\n,\n\n    \nu\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:510\n\n\n\n\n\n    \ngetL2error\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nuexact\n,\n\n    \nuh\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:12\n\n\n\n\n\n    \ngetL2error\n(\n\n    \nnode\n,\n\n    \nelem\n,\n\n    \nuexact\n,\n\n    \nuh\n,\n\n    \nquad\ud835\udcaa\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_error.jl:12", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/fem_tools/#internal-finite-element-tools", 
            "text": "", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/fem_tools/#general", 
            "text": "#  DifferentialEquations     Module .", 
            "title": "General"
        }, 
        {
            "location": "/internals/fem_tools/#mesh-tools", 
            "text": "#  DifferentialEquations.CFL\u03bd     Function .  CFL\u03bd(\u0394t,\u0394x)  Computes the CFL-condition \u03bd= \u0394t/\u0394x  source  Methods   \n     CFL\u03bd ( \u0394t ,  \u0394x ) \n    defined at\n     src/fem/meshes.jl:122    #  DifferentialEquations.CFL\u03bc     Function .  CFL\u03bc(\u0394t,\u0394x)  Computes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)  source  Methods   \n     CFL\u03bc ( \u0394t ,  \u0394x ) \n    defined at\n     src/fem/meshes.jl:115", 
            "title": "Mesh Tools"
        }, 
        {
            "location": "/internals/fem_tools/#solver-tools", 
            "text": "#  DifferentialEquations.\u2207basis     Function .  \u2207basis(node,elem)  Returns the \u2207u of the barycentric basis elements.  source  Methods   \n     \u2207basis ( node ,  elem ) \n    defined at\n     src/fem/fem_error.jl:490    #  DifferentialEquations.quadfbasis     Function .  quadfbasis(f,gD,gN,A,u,node,elem,area,bdnode,mid,N,dirichlet,neumann,islinear,numvars;gNquad\ud835\udcaa=2)  Performs the order 2 quadrature to calculate the vector from the term $ <f ,v>$ for linear elements.  source  Methods   \n     quadfbasis ( \n     f ,      gD ,      gN ,      A ,      u ,      node ,      elem ,      area ,      bdnode ,      mid ,      N ,      dirichlet ,      neumann ,      islinear ,      numvars  ) \n    defined at\n     src/fem/fem_solve.jl:259    #  DifferentialEquations.quadpts     Function .  quadpts(\ud835\udcaa)  Returns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.  Reference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.  source  Methods   \n     quadpts ( \ud835\udcaa ) \n    defined at\n     src/fem/fem_error.jl:146    #  DifferentialEquations.quadpts1     Function .  quadpts1(\ud835\udcaa)  References: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/  source  Methods   \n     quadpts1 ( \ud835\udcaa ) \n    defined at\n     src/fem/fem_error.jl:265    #  DifferentialEquations.assemblematrix     Function .  assemblematrix(node,elem;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  source  assemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  source  Methods   \n     assemblematrix ( FEMmesh :: DifferentialEquations.FEMmesh ) \n    defined at\n     src/fem/fem_assembly.jl:72   \n     assemblematrix ( node ,  elem ) \n    defined at\n     src/fem/fem_assembly.jl:19    #  DifferentialEquations.\u2207u     Function .  \u2207u(node,elem,u,D\u03bb=[])  Estimates \u2207u of u on the mesh (node,elem)  source  Methods   \n     \u2207u ( \n     node ,      elem ,      u  ) \n    defined at\n     src/fem/fem_error.jl:473   \n     \u2207u ( \n     node ,      elem ,      u ,      D\u03bb  ) \n    defined at\n     src/fem/fem_error.jl:473", 
            "title": "Solver Tools"
        }, 
        {
            "location": "/internals/fem_tools/#error-tools", 
            "text": "#  DifferentialEquations.getH1error     Function .  function getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])  getH1error(fem_mesh::FEMmesh,Du,u)  Estimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.  source  Methods   \n     getH1error ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      Du ,      u  ) \n    defined at\n     src/fem/fem_error.jl:518   \n     getH1error ( \n     node ,      elem ,      Du ,      uh  ) \n    defined at\n     src/fem/fem_error.jl:353   \n     getH1error ( \n     node ,      elem ,      Du ,      uh ,      K  ) \n    defined at\n     src/fem/fem_error.jl:353   \n     getH1error ( \n     node ,      elem ,      Du ,      uh ,      K ,      quad\ud835\udcaa  ) \n    defined at\n     src/fem/fem_error.jl:353    #  DifferentialEquations.getL2error     Function .  getL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])  getL2error(fem_mesh::FEMmesh,sol,u)  Estimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.  source  Methods   \n     getL2error ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      sol ,      u  ) \n    defined at\n     src/fem/fem_error.jl:510   \n     getL2error ( \n     node ,      elem ,      uexact ,      uh  ) \n    defined at\n     src/fem/fem_error.jl:12   \n     getL2error ( \n     node ,      elem ,      uexact ,      uh ,      quad\ud835\udcaa  ) \n    defined at\n     src/fem/fem_error.jl:12", 
            "title": "Error Tools"
        }, 
        {
            "location": "/internals/extras/", 
            "text": "Extra Functions\n\n\n#\n\n\nDifferentialEquations.getNoise\n \n \nFunction\n.\n\n\ngetNoise(N,node,elem;noisetype=:White)\n\n\nReturns a random vector corresponding to the noise type which was chosen.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ngetNoise\n(\n\n    \nu\n,\n\n    \nnode\n,\n\n    \nelem\n\n\n)\n\n    defined at\n    \nsrc/general/stochastic_utils.jl:7\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.numparameters\n \n \nFunction\n.\n\n\nnumparameters(f)\n\n\nReturns the number of parameters of \nf\n for the method which has the most parameters.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nnumparameters\n(\nf\n)\n\n    defined at\n    \nsrc/general/problems.jl:452\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.Tableau\n \n \nType\n.\n\n\nTableau: Holds the information for a Runge-Kutta Tableau\n\n\nsource\n\n\n\n\nMaking Build Work\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nFunction\n.\n\n\nFinite Element Poisson Equation Solver\n\n\nsolve(fem_mesh::FEMmesh,pdeProb::PoissonProblem)\n\n\nTakes in a definition for the heat equation $-\u0394u = f$ on \nfem_mesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic Poisson equation $-\u0394u = f + \u03c3dW$.\n\n\nKeyword Arguments\n\n\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\n\n\n:Direct\n = Solves \nAx=b\n using \n\\\n\n\n:CG\n = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.\n\n\n:GMRES\n = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.\n\n\ntimeseries_steps\n = If \nsave_timeseries=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\n\n\n\n\n\n\nsource\n\n\nFinite Element Heat Equation Solver\n\n\nsolve(fem_mesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation $u_t = \u0394u + f$ on \nfem_mesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic heat equation $u_t = \u0394u + f + \u03c3dW_t$.\n\n\nKeyword Arguments\n\n\n\n\n\n\nalg\n = Solution algorithm. Default is :Euler. The choices are:\n\n\n\n\n\n\nLinear\n\n\n\n\n:Euler\n (Explicit)\n\n\n:ImplicitEuler\n (Implicit)\n\n\n\n\n:CrankNicholson\n (Implicit)\n\n\n\n\nNonlinear\n\n\n\n\n\n\n\n\n:Euler\n (Explicit)\n\n\n\n\n:ImplicitEuler\n (Nonlinear Solve)\n\n\n:CrankNicholson\n (Nonlinear Solve)\n\n\n:SemiImplicitEuler\n (Implicit)\n\n\n:SemiImplicitCrankNicholson\n (Implicit)\n\n\n\n\n\n\n\n\n\n\n\n\nExplicit algorithms only require solving matrix multiplications \nAu\n. Implicit algorithms require solving the linear equation \nAx=b\n where \nx\n is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).\n\n\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\n\n\n:Direct\n = Solves using \n\\\n (no factorization). Not recommended.\n\n\n:Cholesky\n = Cholsky decomposition. Only stable of $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite. This means that this works best when \u0394t is small. When applicable, this is the fastest.\n\n\n:LU\n = LU-Decomposition. A good mix between fast and stable.\n\n\n:QR\n = QR-Decomposition. Less numerical roundoff error than \nLU\n, but slightly slower.\n\n\n:SVD\n = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.\n\n\n:CG\n = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.\n\n\n:GMRES\n = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.\n\n\nsave_timeseries\n = Makes the algorithm save the output at every \ntimeseries_steps\n timesteps. By default save_timeseries is false.\n\n\ntimeseries_steps\n = If \nsave_timeseries=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\nprogress_steps\n = The number of steps between updates of the progress bar. Defaults to 1000.\n\n\nprogressbar\n = Turns on/off use of the Juno progress bar. Defaults to true. Requires Juno.\n\n\n\n\n\n\n\n\nsource\n\n\nsolve(prob::StokesProblem,mesh::FDMMesh)\n\n\nSolves the given stationary Stokes problem on the given finite difference mesh.\n\n\nKeyword Arguments\n\n\n\n\nconverrors\n: Whether to calculate all of the errors along the convergence. Default is true.\n\n\nmaxiters\n: Maximum number of iterations before haulting. Default is 100.\n\n\nalg\n: The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".\n\n\nlevel\n: The number of levels in the Multigrid. Default is 2.\n\n\nsmoothSteps\n: The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.\n\n\ncoarseSteps\n: The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.\n\n\ngsiters\n: The number of Gauss-Seidel iterations to do at each step. Default is 20.\n\n\n\n\nsource\n\n\n`solve(prob::SDEProblem,tspan)``\n\n\nSolves the SDE as defined by prob on the time interval tspan. If not given, tspan defaults to [0,1].\n\n\nKeyword Arguments\n\n\n\n\n\u0394t\n: Sets the initial stepsize. Defaults to an automatic choice.\n\n\nsave_timeseries\n: Saves the result at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes how many steps between saving a value for the timeseries. Defaults to 1.\n\n\nadaptive\n - Turns on adaptive timestepping for appropriate methods. Default is false.\n\n\n\u03b3\n - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.\n\n\nqmax\n - Defines the maximum value possible for the adaptive q. Default is 1.125.\n\n\n\u03b4\n - The weight-factor in the error estimate. Default is 1/6.\n\n\nablstol\n - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.\n\n\nreltol\n - Relative tolerance in adaptive timestepping. Defaults to 1e-6.\n\n\nmaxiters\n - Maximum number of iterations before stopping. Defaults to 1e9.\n\n\n\u0394tmax\n - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.\n\n\n\u0394tmin\n - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.\n\n\ninternalnorm\n - The norm for which error estimates are calculated. Default is 2.\n\n\nprogressbar\n - Turns on/off the Juno progressbar. Defualt is false.\n\n\nprogress_steps\n - Numbers of steps between updates of the progress bar. Default is 1000.\n\n\ndiscard_length\n - Size at which to discard future information in adaptive. Default is 1e-15.\n\n\ntableau\n: The tableau for an \n:SRA\n or \n:SRI\n algorithm. Defaults to SRIW1 or SRA1.\n\n\nadaptivealg\n: The adaptive timestepping algorithm. Default is \n:RSwm3\n.\n\n\n\n\nalg\n: String which defines the solver algorithm. Defult is \"SRIW1Optimized\". Possibilities are:\n\n\n\n\n:EM\n- The Euler-Maruyama method.\n\n\n:RKMil\n - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.\n\n\n:SRA\n - The strong Order 2.0 methods for additive SDEs due to Rossler. Not yet implemented.   Default tableau is for SRA1.\n\n\n:SRI\n - The strong Order 1.5 methods for diagonal/scalar SDEs due to Rossler. Default tableau is for SRIW1.\n\n\n:SRIW1Optimized\n - An optimized version of SRIW1. Strong Order 1.5.\n\n\n:SRA1Optimized\n - An optimized version of SRIA1. Strong Order 2.0.\n\n\n:SRAVectorized\n - A vectorized implementation of SRA algorithms. Requires 1-dimensional problem.\n\n\n:SRIVectorized\n - A vectorized implementation of SRI algorithms. Requires 1-dimensional problem.\n\n\n\n\n\n\n\n\nsource\n\n\nsolve(prob::ODEProblem,tspan)\n\n\nSolves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].\n\n\nKeyword Arguments\n\n\n\n\n\u0394t\n: Sets the initial stepsize. Defaults to an automatic choice.\n\n\nsave_timeseries\n: Saves the result at every timeseries_steps steps. Default is true.\n\n\ntimeseries_steps\n: Denotes how many steps between saving a value for the timeseries. Defaults to 1.\n\n\ntableau\n: The tableau for an \n:ExplicitRK\n algorithm. Defaults to a Dormand-Prince 4/5 method.\n\n\nadaptive\n - Turns on adaptive timestepping for appropriate methods. Default is true.\n\n\n\u03b3\n - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.\n\n\nqmax\n - Defines the maximum value possible for the adaptive q. Default is 10.\n\n\nablstol\n - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.\n\n\nreltol\n - Relative tolerance in adaptive timestepping. Defaults to 1e-6.\n\n\nmaxiters\n - Maximum number of iterations before stopping. Defaults to 1e9.\n\n\n\u0394tmax\n - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.\n\n\n\u0394tmin\n - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.\n\n\nautodiff\n - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use \nNLsolve\n. Default is true.\n\n\ninternalnorm\n - The norm for which error estimates are calculated. Default is 2.\n\n\nprogressbar\n - Turns on/off the Juno progressbar. Defualt is false.\n\n\nprogress_steps\n - Numbers of steps between updates of the progress bar. Default is 1000.\n\n\n\n\nalg\n: String which defines the solver algorithm. Defult is \n:ExplicitRK\n. Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify \nSSBETA=0.03\n as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as \nMAXSS\n (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax \n\u0394tmax\n or \nMAXSS\n. The possibilities for the solvers are:\n\n\n\n\n\n\nDifferentialEquations.jl\n\n\n\n\n:Euler\n- The canonical forward Euler method.\n\n\n:Midpoint\n - The second order midpoint method.\n\n\n:RK4\n - The canonical Runge-Kutta Order 4 method.\n\n\n\n\n:ExplicitRK\n - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument \ntab=tableau\n. The default tableau is for Dormand-Prine 4/5. Other supplied tableaus include:\n\n\n\n\nconstructRalston()\n - Returns a tableau for Ralston's method\n\n\nconstructRKF()\n - Returns a tableau for Runge-Kutta-Fuhlberg 4/5\n\n\nconstructBogakiShampine()\n - Returns a tableau for Bogakai-Shampine's 2/3 method.\n\n\nconstructCashKarp()\n - Returns a tableau for the Cash-Karp method 4/5.\n\n\nconstructDormandPrince()\n - Returns a tableau for Dormand-Prince 4/5.\n\n\nconstructRKF8()\n - Returns a tableau for Runge-Kutta-Fuhlberg Order 7/8 method.\n\n\nconstructDormandPrice8()\n - Returns a tableau for the Dormand-Prince Order 7/8 method.\n          * \n:ImplicitEuler\n - A 1st order implicit solver. Unconditionally stable.\n          * \n:Trapezoid\n - A second order unconditionally stable implicit solver. Good for highly stiff.\n          * \n:Rosenbrock32\n - A fast solver which is good for stiff equations.\n\n\nODEInterface.jl\n\n\n\n\n\n\n\n\n\n\n\n\n:dopri5\n - Hairer's classic implementation of the Dormand-Prince 4/5 method.\n\n\n\n\n:dop853\n - Explicit Runge-Kutta 8(5,3) by Dormand-Prince\n\n\n:odex\n - GBS extrapolation-algorithm based on the midpoint rule\n\n\n:seulex\n - extrapolation-algorithm bsed on the linear implicit Euler method\n\n\n:radau\n - implicit Runge-Kutta (Rdau IIA) of variable order between 5 and 13\n\n\n\n\n:radau5\n - implicit Runge-Kutta method (Radau IIA) of order 5\n\n\n\n\nODE.jl\n\n\n\n\n\n\n\n\n:ode23\n - Bogakai-Shampine's 2/3 method\n\n\n\n\n:ode45\n - Dormand-Prince's 4/5 method\n\n\n:ode78\n - Runge-Kutta-Fuhlberg 7/8 method\n\n\n:ode23s\n - Rosenbrock's 2/3 method\n\n\n:ode1\n - Forward Euler\n\n\n:ode2_midpoint\n - Midpoint Method\n\n\n:ode2_heun\n - Heun's Method\n\n\n:ode4\n - RK4\n\n\n:ode45_fe\n - Runge-Kutta-Fuhlberg 4/5 method\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsolve\n(\nprob\n::\nDifferentialEquations.ODEProblem\n)\n\n    defined at\n    \nsrc/ode/ode_solve.jl:75\n\n\n\n\n\n    \nsolve\n(\nprob\n::\nDifferentialEquations.SDEProblem\n)\n\n    defined at\n    \nsrc/sde/sde_solve.jl:45\n\n\n\n\n\n    \nsolve\n(\n\n    \nprob\n::\nDifferentialEquations.StokesProblem\n,\n\n    \nmesh\n::\nDifferentialEquations.FDMMesh\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:304\n\n\n\n\n\n    \nsolve\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nprob\n::\nDifferentialEquations.HeatProblem\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_solve.jl:180\n\n\n\n\n\n    \nsolve\n(\n\n    \nfem_mesh\n::\nDifferentialEquations.FEMmesh\n,\n\n    \nprob\n::\nDifferentialEquations.PoissonProblem\n\n\n)\n\n    defined at\n    \nsrc/fem/fem_solve.jl:28\n\n\n\n\n\n    \nsolve\n(\n\n    \nprob\n::\nDifferentialEquations.SDEProblem\n,\n\n    \ntspan\n::\nAbstractArray\n\n\n)\n\n    defined at\n    \nsrc/sde/sde_solve.jl:45\n\n\n\n\n\n    \nsolve\n(\n\n    \nprob\n::\nDifferentialEquations.ODEProblem\n,\n\n    \ntspan\n::\nAbstractArray\n\n\n)\n\n    defined at\n    \nsrc/ode/ode_solve.jl:75\n\n\n\n\n\n\n\n#\n\n\nBase.size\n \n \nFunction\n.\n\n\nsize(mesh::FDMMesh)\n\n\nReturns gridSize.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsize\n(\nmesh\n::\nDifferentialEquations.FDMMesh\n)\n\n    defined at\n    \nsrc/fem/meshes.jl:215\n\n\n\n\n\n    \nsize\n(\nsol\n::\nDifferentialEquations.DESolution\n)\n\n    defined at\n    \nsrc/general/solutions.jl:219\n\n\n\n\n\n\n\nHiding 102 methods defined outside of this package.\n\n\n#\n\n\nBase.length\n \n \nFunction\n.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation\n\n\nsource\n\n\nBase.length(tab::ExplicitRK)\n\n\nDefines the length of a Runge-Kutta method to be the number of stages.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nlength\n(\nsim\n::\nDifferentialEquations.MonteCarloSimulation\n)\n\n    defined at\n    \nsrc/general/stochastic_utils.jl:50\n\n\n\n\n\n    \nlength\n(\nsim\n::\nDifferentialEquations.ConvergenceSimulation\n)\n\n    defined at\n    \nsrc/general/convergence.jl:196\n\n\n\n\n\n    \nlength\n(\ntab\n::\nDifferentialEquations.ExplicitRK\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:21\n\n\n\n\n\n    \nlength\n(\nsol\n::\nDifferentialEquations.DESolution\n)\n\n    defined at\n    \nsrc/general/solutions.jl:218\n\n\n\n\n\n\n\nHiding 108 methods defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.@materialize\n \n \nMacro\n.\n\n\nSplats keys from a dict into variables\n\n\n@materialize a, b, c = dict\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \n@materialize\n(\ndict_splat\n::\nANY\n<\n:Any\n)\n\n    defined at\n    \nsrc/general/misc_utils.jl:82", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#extra-functions", 
            "text": "#  DifferentialEquations.getNoise     Function .  getNoise(N,node,elem;noisetype=:White)  Returns a random vector corresponding to the noise type which was chosen.  source  Methods   \n     getNoise ( \n     u ,      node ,      elem  ) \n    defined at\n     src/general/stochastic_utils.jl:7    #  DifferentialEquations.numparameters     Function .  numparameters(f)  Returns the number of parameters of  f  for the method which has the most parameters.  source  Methods   \n     numparameters ( f ) \n    defined at\n     src/general/problems.jl:452    #  DifferentialEquations.Tableau     Type .  Tableau: Holds the information for a Runge-Kutta Tableau  source", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#making-build-work", 
            "text": "#  DifferentialEquations.solve     Function .  Finite Element Poisson Equation Solver  solve(fem_mesh::FEMmesh,pdeProb::PoissonProblem)  Takes in a definition for the heat equation $-\u0394u = f$ on  fem_mesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic Poisson equation $-\u0394u = f + \u03c3dW$.  Keyword Arguments    solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:   :Direct  = Solves  Ax=b  using  \\  :CG  = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.  :GMRES  = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.  timeseries_steps  = If  save_timeseries=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.     source  Finite Element Heat Equation Solver  solve(fem_mesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation $u_t = \u0394u + f$ on  fem_mesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic heat equation $u_t = \u0394u + f + \u03c3dW_t$.  Keyword Arguments    alg  = Solution algorithm. Default is :Euler. The choices are:    Linear   :Euler  (Explicit)  :ImplicitEuler  (Implicit)   :CrankNicholson  (Implicit)   Nonlinear     :Euler  (Explicit)   :ImplicitEuler  (Nonlinear Solve)  :CrankNicholson  (Nonlinear Solve)  :SemiImplicitEuler  (Implicit)  :SemiImplicitCrankNicholson  (Implicit)       Explicit algorithms only require solving matrix multiplications  Au . Implicit algorithms require solving the linear equation  Ax=b  where  x  is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).    solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:   :Direct  = Solves using  \\  (no factorization). Not recommended.  :Cholesky  = Cholsky decomposition. Only stable of $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite. This means that this works best when \u0394t is small. When applicable, this is the fastest.  :LU  = LU-Decomposition. A good mix between fast and stable.  :QR  = QR-Decomposition. Less numerical roundoff error than  LU , but slightly slower.  :SVD  = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.  :CG  = Conjugate-Gradient. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is positive definite.  :GMRES  = GMRES. Best when the space is very large and $I \u00b1 \u0394tM\u207b\u00b9A$ is not positive definite.  save_timeseries  = Makes the algorithm save the output at every  timeseries_steps  timesteps. By default save_timeseries is false.  timeseries_steps  = If  save_timeseries=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.  progress_steps  = The number of steps between updates of the progress bar. Defaults to 1000.  progressbar  = Turns on/off use of the Juno progress bar. Defaults to true. Requires Juno.     source  solve(prob::StokesProblem,mesh::FDMMesh)  Solves the given stationary Stokes problem on the given finite difference mesh.  Keyword Arguments   converrors : Whether to calculate all of the errors along the convergence. Default is true.  maxiters : Maximum number of iterations before haulting. Default is 100.  alg : The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".  level : The number of levels in the Multigrid. Default is 2.  smoothSteps : The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.  coarseSteps : The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.  gsiters : The number of Gauss-Seidel iterations to do at each step. Default is 20.   source  `solve(prob::SDEProblem,tspan)``  Solves the SDE as defined by prob on the time interval tspan. If not given, tspan defaults to [0,1].  Keyword Arguments   \u0394t : Sets the initial stepsize. Defaults to an automatic choice.  save_timeseries : Saves the result at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes how many steps between saving a value for the timeseries. Defaults to 1.  adaptive  - Turns on adaptive timestepping for appropriate methods. Default is false.  \u03b3  - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.  qmax  - Defines the maximum value possible for the adaptive q. Default is 1.125.  \u03b4  - The weight-factor in the error estimate. Default is 1/6.  ablstol  - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.  reltol  - Relative tolerance in adaptive timestepping. Defaults to 1e-6.  maxiters  - Maximum number of iterations before stopping. Defaults to 1e9.  \u0394tmax  - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.  \u0394tmin  - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.  internalnorm  - The norm for which error estimates are calculated. Default is 2.  progressbar  - Turns on/off the Juno progressbar. Defualt is false.  progress_steps  - Numbers of steps between updates of the progress bar. Default is 1000.  discard_length  - Size at which to discard future information in adaptive. Default is 1e-15.  tableau : The tableau for an  :SRA  or  :SRI  algorithm. Defaults to SRIW1 or SRA1.  adaptivealg : The adaptive timestepping algorithm. Default is  :RSwm3 .   alg : String which defines the solver algorithm. Defult is \"SRIW1Optimized\". Possibilities are:   :EM - The Euler-Maruyama method.  :RKMil  - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.  :SRA  - The strong Order 2.0 methods for additive SDEs due to Rossler. Not yet implemented.   Default tableau is for SRA1.  :SRI  - The strong Order 1.5 methods for diagonal/scalar SDEs due to Rossler. Default tableau is for SRIW1.  :SRIW1Optimized  - An optimized version of SRIW1. Strong Order 1.5.  :SRA1Optimized  - An optimized version of SRIA1. Strong Order 2.0.  :SRAVectorized  - A vectorized implementation of SRA algorithms. Requires 1-dimensional problem.  :SRIVectorized  - A vectorized implementation of SRI algorithms. Requires 1-dimensional problem.     source  solve(prob::ODEProblem,tspan)  Solves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].  Keyword Arguments   \u0394t : Sets the initial stepsize. Defaults to an automatic choice.  save_timeseries : Saves the result at every timeseries_steps steps. Default is true.  timeseries_steps : Denotes how many steps between saving a value for the timeseries. Defaults to 1.  tableau : The tableau for an  :ExplicitRK  algorithm. Defaults to a Dormand-Prince 4/5 method.  adaptive  - Turns on adaptive timestepping for appropriate methods. Default is true.  \u03b3  - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.  qmax  - Defines the maximum value possible for the adaptive q. Default is 10.  ablstol  - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.  reltol  - Relative tolerance in adaptive timestepping. Defaults to 1e-6.  maxiters  - Maximum number of iterations before stopping. Defaults to 1e9.  \u0394tmax  - Maximum \u0394t for adaptive timestepping. Defaults to half the timespan.  \u0394tmin  - Minimum \u0394t for adaptive timestepping. Defaults to 1e-10.  autodiff  - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use  NLsolve . Default is true.  internalnorm  - The norm for which error estimates are calculated. Default is 2.  progressbar  - Turns on/off the Juno progressbar. Defualt is false.  progress_steps  - Numbers of steps between updates of the progress bar. Default is 1000.   alg : String which defines the solver algorithm. Defult is  :ExplicitRK . Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify  SSBETA=0.03  as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as  MAXSS  (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax  \u0394tmax  or  MAXSS . The possibilities for the solvers are:    DifferentialEquations.jl   :Euler - The canonical forward Euler method.  :Midpoint  - The second order midpoint method.  :RK4  - The canonical Runge-Kutta Order 4 method.   :ExplicitRK  - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument  tab=tableau . The default tableau is for Dormand-Prine 4/5. Other supplied tableaus include:   constructRalston()  - Returns a tableau for Ralston's method  constructRKF()  - Returns a tableau for Runge-Kutta-Fuhlberg 4/5  constructBogakiShampine()  - Returns a tableau for Bogakai-Shampine's 2/3 method.  constructCashKarp()  - Returns a tableau for the Cash-Karp method 4/5.  constructDormandPrince()  - Returns a tableau for Dormand-Prince 4/5.  constructRKF8()  - Returns a tableau for Runge-Kutta-Fuhlberg Order 7/8 method.  constructDormandPrice8()  - Returns a tableau for the Dormand-Prince Order 7/8 method.\n          *  :ImplicitEuler  - A 1st order implicit solver. Unconditionally stable.\n          *  :Trapezoid  - A second order unconditionally stable implicit solver. Good for highly stiff.\n          *  :Rosenbrock32  - A fast solver which is good for stiff equations.  ODEInterface.jl       :dopri5  - Hairer's classic implementation of the Dormand-Prince 4/5 method.   :dop853  - Explicit Runge-Kutta 8(5,3) by Dormand-Prince  :odex  - GBS extrapolation-algorithm based on the midpoint rule  :seulex  - extrapolation-algorithm bsed on the linear implicit Euler method  :radau  - implicit Runge-Kutta (Rdau IIA) of variable order between 5 and 13   :radau5  - implicit Runge-Kutta method (Radau IIA) of order 5   ODE.jl     :ode23  - Bogakai-Shampine's 2/3 method   :ode45  - Dormand-Prince's 4/5 method  :ode78  - Runge-Kutta-Fuhlberg 7/8 method  :ode23s  - Rosenbrock's 2/3 method  :ode1  - Forward Euler  :ode2_midpoint  - Midpoint Method  :ode2_heun  - Heun's Method  :ode4  - RK4  :ode45_fe  - Runge-Kutta-Fuhlberg 4/5 method       source  Methods   \n     solve ( prob :: DifferentialEquations.ODEProblem ) \n    defined at\n     src/ode/ode_solve.jl:75   \n     solve ( prob :: DifferentialEquations.SDEProblem ) \n    defined at\n     src/sde/sde_solve.jl:45   \n     solve ( \n     prob :: DifferentialEquations.StokesProblem ,      mesh :: DifferentialEquations.FDMMesh  ) \n    defined at\n     src/fdm/stokes_solve.jl:304   \n     solve ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      prob :: DifferentialEquations.HeatProblem  ) \n    defined at\n     src/fem/fem_solve.jl:180   \n     solve ( \n     fem_mesh :: DifferentialEquations.FEMmesh ,      prob :: DifferentialEquations.PoissonProblem  ) \n    defined at\n     src/fem/fem_solve.jl:28   \n     solve ( \n     prob :: DifferentialEquations.SDEProblem ,      tspan :: AbstractArray  ) \n    defined at\n     src/sde/sde_solve.jl:45   \n     solve ( \n     prob :: DifferentialEquations.ODEProblem ,      tspan :: AbstractArray  ) \n    defined at\n     src/ode/ode_solve.jl:75    #  Base.size     Function .  size(mesh::FDMMesh)  Returns gridSize.  source  Methods   \n     size ( mesh :: DifferentialEquations.FDMMesh ) \n    defined at\n     src/fem/meshes.jl:215   \n     size ( sol :: DifferentialEquations.DESolution ) \n    defined at\n     src/general/solutions.jl:219    Hiding 102 methods defined outside of this package.  #  Base.length     Function .  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation  source  Base.length(tab::ExplicitRK)  Defines the length of a Runge-Kutta method to be the number of stages.  source  Methods   \n     length ( sim :: DifferentialEquations.MonteCarloSimulation ) \n    defined at\n     src/general/stochastic_utils.jl:50   \n     length ( sim :: DifferentialEquations.ConvergenceSimulation ) \n    defined at\n     src/general/convergence.jl:196   \n     length ( tab :: DifferentialEquations.ExplicitRK ) \n    defined at\n     src/ode/ode_tableaus.jl:21   \n     length ( sol :: DifferentialEquations.DESolution ) \n    defined at\n     src/general/solutions.jl:218    Hiding 108 methods defined outside of this package.  #  DifferentialEquations.@materialize     Macro .  Splats keys from a dict into variables  @materialize a, b, c = dict  source  Methods   \n     @materialize ( dict_splat :: ANY < :Any ) \n    defined at\n     src/general/misc_utils.jl:82", 
            "title": "Making Build Work"
        }, 
        {
            "location": "/internals/solver_helpers/", 
            "text": "Solver Helpers\n\n\nThis package includes the documentation for the helper functions for the various solvers.\n\n\n\n\nODE Solver Extras\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nBase.length(tab::ExplicitRK)\n\n\nDefines the length of a Runge-Kutta method to be the number of stages.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.ExplicitRK\n \n \nType\n.\n\n\nExplicitRK\n\n\nHolds a tableau which defines an explicit Runge-Kutta method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nExplicitRK\n(\n\n    \nA\n,\n\n    \nc\n,\n\n    \n\u03b1\n,\n\n    \norder\n\n\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:13\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.ODE_DEFAULT_TABLEAU\n \n \nConstant\n.\n\n\nODE_DEFAULT_TABLEAU\n\n\nSets the default tableau for the ODE solver. Currently Dormand-Prince 4/5.\n\n\nsource\n\n\n#\n\n\nDifferentialEquations.constructCashKarp\n \n \nFunction\n.\n\n\nconstructCashKarp()\n\n\nConstructs the tableau object for the Cash-Karp Order 4/5 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructCashKarp\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:89\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructRalston\n \n \nFunction\n.\n\n\nconstructRalston()\n\n\nConstructs the tableau object for Ralston's Order 2 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructRalston\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:42\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructDormandPrince\n \n \nFunction\n.\n\n\nconstructDormandPrince()\n\n\nConstructs the tableau object for the Dormand-Prince Order 4/5 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructDormandPrince\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:107\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructDormandPrince8\n \n \nFunction\n.\n\n\nconstructDormandPrice8()\n\n\nConstructs the tableau object for the Dormand-Prince Order 7/8 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructDormandPrince8\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:151\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructBogakiShampine\n \n \nFunction\n.\n\n\nconstructBogakiShampine()\n\n\nConstructs the tableau object for the Bogakai-Shampine Order 2/3 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructBogakiShampine\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:73\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructHuen\n \n \nFunction\n.\n\n\nconstructHuen()\n\n\nConstructs the tableau object for Huen's Order 2 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructHuen\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:29\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructRKF\n \n \nFunction\n.\n\n\nconstructRKF()\n\n\nConstructs the tableau object for the Runge-Kutta-Fuhlberg Order 4/5 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructRKF\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:55\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructRKF8\n \n \nFunction\n.\n\n\nconstructRKF8()\n\n\nConstructs the tableau object for the Runge-Kutta-Fuhlberg Order 7/8 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructRKF8\n(\n)\n\n    defined at\n    \nsrc/ode/ode_tableaus.jl:126\n\n\n\n\n\n\n\n\n\nSDE Solver Extras\n\n\n#\n\n\nDifferentialEquations.monteCarloSim\n \n \nFunction\n.\n\n\nmonteCarloSim(\u0394t::Number,prob::SDEProblem)\n\n\nPerforms a parallel Monte-Carlo simulation to solve the SDE problem with \u0394t numMonte times. Returns a vector of solution objects.\n\n\nKeyword Arguments\n\n\n\n\nT - Final time. Default is 1.\n\n\nnumMonte - Number of Monte-Carlo simulations to run. Default is 10000\n\n\nsave_timeseries - Denotes whether save_timeseries should be turned on in each run. Default is true.\n\n\nalg - Algorithm for solving the SDEs. Default is \"EM\"\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmonteCarloSim\n(\nprob\n::\nDifferentialEquations.SDEProblem\n)\n\n    defined at\n    \nsrc/general/stochastic_utils.jl:25\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.RosslerSRI\n \n \nType\n.\n\n\nRosslerSRI\n\n\nHolds the Butcher tableaus for a Rosser SRI method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nRosslerSRI\n(\n\n    \nc\u2080\n,\n\n    \nc\u2081\n,\n\n    \nA\u2080\n,\n\n    \nA\u2081\n,\n\n    \nB\u2080\n,\n\n    \nB\u2081\n,\n\n    \n\u03b1\n,\n\n    \n\u03b2\u2081\n,\n\n    \n\u03b2\u2082\n,\n\n    \n\u03b2\u2083\n,\n\n    \n\u03b2\u2084\n\n\n)\n\n    defined at\n    \nsrc/sde/sde_tableaus.jl:7\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.RosslerSRA\n \n \nType\n.\n\n\nRosslerSRA\n\n\nHolds the Butcher tableaus for a Rosser SRA method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nRosslerSRA\n(\n\n    \nc\u2080\n,\n\n    \nc\u2081\n,\n\n    \nA\u2080\n,\n\n    \nB\u2080\n,\n\n    \n\u03b1\n,\n\n    \n\u03b2\u2081\n,\n\n    \n\u03b2\u2082\n\n\n)\n\n    defined at\n    \nsrc/sde/sde_tableaus.jl:26\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nDifferentialEquations.constructSRA1\n \n \nFunction\n.\n\n\nconstructSRA1()\n\n\nConstructs the taleau type for the SRA1 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructSRA1\n(\n)\n\n    defined at\n    \nsrc/sde/sde_tableaus.jl:75\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.constructSRIW1\n \n \nFunction\n.\n\n\nconstructSRIW1()\n\n\nConstructs the tableau type for the SRIW1 method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nconstructSRIW1\n(\n)\n\n    defined at\n    \nsrc/sde/sde_tableaus.jl:41\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.checkSRAOrder\n \n \nFunction\n.\n\n\ncheckSRAOrder(RosslerSRI)\n\n\nDetermines whether the order conditions are met via the tableaus of the SRA method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncheckSRAOrder\n(\nSRA\n)\n\n    defined at\n    \nsrc/sde/sde_tableaus.jl:130\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.checkSRIOrder\n \n \nFunction\n.\n\n\ncheckSRIOrder(RosslerSRI)\n\n\nDetermines whether the order conditions are met via the tableaus of the SRI method.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncheckSRIOrder\n(\nRosslerSRI\n)\n\n    defined at\n    \nsrc/sde/sde_tableaus.jl:93\n\n\n\n\n\n\n\n\n\nStationary Stokes\n\n\n#\n\n\nDifferentialEquations.GS\u03b4q!\n \n \nFunction\n.\n\n\nGS\u03b4q!(\u03b4q,rp,\u0394xs)\n\n\nPerforms a Gauss-Seidel iteration for \u03b4q.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nGS\u03b4q!\n(\n\n    \n\u03b4q\n,\n\n    \nrp\n,\n\n    \n\u0394xs\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:77\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.GSu!\n \n \nFunction\n.\n\n\nGSu!(u,f\u2081,\u0394xs,p,ugD,grids,ux,uy)\n\n\nPerforms a Gauss-Seidel iteration on u.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nGSu!\n(\n\n    \nu\n,\n\n    \nf\u2081\n,\n\n    \n\u0394xs\n,\n\n    \np\n,\n\n    \nugD\n,\n\n    \ngrids\n,\n\n    \nux\n,\n\n    \nuy\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:7\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.calc_rp!\n \n \nFunction\n.\n\n\ncalc_rp!(rp,u,v,\u0394xs,g,px,py)\n\n\nCalculates the rp from the u and v's.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncalc_rp!\n(\n\n    \nrp\n,\n\n    \nu\n,\n\n    \nv\n,\n\n    \n\u0394xs\n,\n\n    \ng\n,\n\n    \npx\n,\n\n    \npy\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:55\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.update_p!\n \n \nFunction\n.\n\n\nupdate_p!(p,\u03b4q,\u0394xs)\n\n\nUpdates p given \u03b4q\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nupdate_p!\n(\n\n    \np\n,\n\n    \n\u03b4q\n,\n\n    \n\u0394xs\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:131\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.update_v!\n \n \nFunction\n.\n\n\nupdate_v!(v,\u03b4q,\u0394xs)\n\n\nUpdates v given \u03b4q\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nupdate_v!\n(\n\n    \nv\n,\n\n    \n\u03b4q\n,\n\n    \n\u0394xs\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:120\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.uzawa_p!\n \n \nFunction\n.\n\n\nuzawa_p!(p,u,v,\u0394xs,g,px,py)\n\n\nSolves for p from u and v using an Uzawa update.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nuzawa_p!\n(\n\n    \np\n,\n\n    \nu\n,\n\n    \nv\n,\n\n    \n\u0394xs\n,\n\n    \ng\n,\n\n    \npx\n,\n\n    \npy\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:66\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.stokes_restriction\n \n \nFunction\n.\n\n\nstokes_restriction(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)\n\n\nRestricts the Stokes problem to the coarsegrid.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nstokes_restriction\n(\n\n    \nu\n,\n\n    \nv\n,\n\n    \np\n,\n\n    \n\u0394xs\n,\n\n    \ngrids\n,\n\n    \nmins\n,\n\n    \nmaxs\n,\n\n    \nugD\n,\n\n    \nvgD\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:163\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.stokes_prolongation\n \n \nFunction\n.\n\n\nstokes_prolongation(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)\n\n\nProlongates the Stokes problem to the fine grid\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nstokes_prolongation\n(\n\n    \nu\n,\n\n    \nv\n,\n\n    \np\n,\n\n    \n\u0394xs\n,\n\n    \ngrids\n,\n\n    \nmins\n,\n\n    \nmaxs\n,\n\n    \nugD\n,\n\n    \nvgD\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:205\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.update_u!\n \n \nFunction\n.\n\n\nupdate_u!(u,\u03b4q,\u0394xs)\n\n\nUpdates u given \u03b4q\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nupdate_u!\n(\n\n    \nu\n,\n\n    \n\u03b4q\n,\n\n    \n\u0394xs\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:109\n\n\n\n\n\n\n\n#\n\n\nDifferentialEquations.GSv!\n \n \nFunction\n.\n\n\nGSv!(v,f\u2082,\u0394xs,p,vgD,grids,vx,vy)\n\n\nPerforms a Gauss-Seidel iteration on v.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nGSv!\n(\n\n    \nv\n,\n\n    \nf\u2082\n,\n\n    \n\u0394xs\n,\n\n    \np\n,\n\n    \nvgD\n,\n\n    \ngrids\n,\n\n    \nvx\n,\n\n    \nvy\n\n\n)\n\n    defined at\n    \nsrc/fdm/stokes_solve.jl:31", 
            "title": "Solver Helpers"
        }, 
        {
            "location": "/internals/solver_helpers/#solver-helpers", 
            "text": "This package includes the documentation for the helper functions for the various solvers.", 
            "title": "Solver Helpers"
        }, 
        {
            "location": "/internals/solver_helpers/#ode-solver-extras", 
            "text": "#  Base.length     Method .  Base.length(tab::ExplicitRK)  Defines the length of a Runge-Kutta method to be the number of stages.  source  #  DifferentialEquations.ExplicitRK     Type .  ExplicitRK  Holds a tableau which defines an explicit Runge-Kutta method.  source  Methods   \n     ExplicitRK ( \n     A ,      c ,      \u03b1 ,      order  ) \n    defined at\n     src/ode/ode_tableaus.jl:13    Hiding 1 method defined outside of this package.  #  DifferentialEquations.ODE_DEFAULT_TABLEAU     Constant .  ODE_DEFAULT_TABLEAU  Sets the default tableau for the ODE solver. Currently Dormand-Prince 4/5.  source  #  DifferentialEquations.constructCashKarp     Function .  constructCashKarp()  Constructs the tableau object for the Cash-Karp Order 4/5 method.  source  Methods   \n     constructCashKarp ( ) \n    defined at\n     src/ode/ode_tableaus.jl:89    #  DifferentialEquations.constructRalston     Function .  constructRalston()  Constructs the tableau object for Ralston's Order 2 method.  source  Methods   \n     constructRalston ( ) \n    defined at\n     src/ode/ode_tableaus.jl:42    #  DifferentialEquations.constructDormandPrince     Function .  constructDormandPrince()  Constructs the tableau object for the Dormand-Prince Order 4/5 method.  source  Methods   \n     constructDormandPrince ( ) \n    defined at\n     src/ode/ode_tableaus.jl:107    #  DifferentialEquations.constructDormandPrince8     Function .  constructDormandPrice8()  Constructs the tableau object for the Dormand-Prince Order 7/8 method.  source  Methods   \n     constructDormandPrince8 ( ) \n    defined at\n     src/ode/ode_tableaus.jl:151    #  DifferentialEquations.constructBogakiShampine     Function .  constructBogakiShampine()  Constructs the tableau object for the Bogakai-Shampine Order 2/3 method.  source  Methods   \n     constructBogakiShampine ( ) \n    defined at\n     src/ode/ode_tableaus.jl:73    #  DifferentialEquations.constructHuen     Function .  constructHuen()  Constructs the tableau object for Huen's Order 2 method.  source  Methods   \n     constructHuen ( ) \n    defined at\n     src/ode/ode_tableaus.jl:29    #  DifferentialEquations.constructRKF     Function .  constructRKF()  Constructs the tableau object for the Runge-Kutta-Fuhlberg Order 4/5 method.  source  Methods   \n     constructRKF ( ) \n    defined at\n     src/ode/ode_tableaus.jl:55    #  DifferentialEquations.constructRKF8     Function .  constructRKF8()  Constructs the tableau object for the Runge-Kutta-Fuhlberg Order 7/8 method.  source  Methods   \n     constructRKF8 ( ) \n    defined at\n     src/ode/ode_tableaus.jl:126", 
            "title": "ODE Solver Extras"
        }, 
        {
            "location": "/internals/solver_helpers/#sde-solver-extras", 
            "text": "#  DifferentialEquations.monteCarloSim     Function .  monteCarloSim(\u0394t::Number,prob::SDEProblem)  Performs a parallel Monte-Carlo simulation to solve the SDE problem with \u0394t numMonte times. Returns a vector of solution objects.  Keyword Arguments   T - Final time. Default is 1.  numMonte - Number of Monte-Carlo simulations to run. Default is 10000  save_timeseries - Denotes whether save_timeseries should be turned on in each run. Default is true.  alg - Algorithm for solving the SDEs. Default is \"EM\"   source  Methods   \n     monteCarloSim ( prob :: DifferentialEquations.SDEProblem ) \n    defined at\n     src/general/stochastic_utils.jl:25    #  DifferentialEquations.RosslerSRI     Type .  RosslerSRI  Holds the Butcher tableaus for a Rosser SRI method.  source  Methods   \n     RosslerSRI ( \n     c\u2080 ,      c\u2081 ,      A\u2080 ,      A\u2081 ,      B\u2080 ,      B\u2081 ,      \u03b1 ,      \u03b2\u2081 ,      \u03b2\u2082 ,      \u03b2\u2083 ,      \u03b2\u2084  ) \n    defined at\n     src/sde/sde_tableaus.jl:7    Hiding 1 method defined outside of this package.  #  DifferentialEquations.RosslerSRA     Type .  RosslerSRA  Holds the Butcher tableaus for a Rosser SRA method.  source  Methods   \n     RosslerSRA ( \n     c\u2080 ,      c\u2081 ,      A\u2080 ,      B\u2080 ,      \u03b1 ,      \u03b2\u2081 ,      \u03b2\u2082  ) \n    defined at\n     src/sde/sde_tableaus.jl:26    Hiding 1 method defined outside of this package.  #  DifferentialEquations.constructSRA1     Function .  constructSRA1()  Constructs the taleau type for the SRA1 method.  source  Methods   \n     constructSRA1 ( ) \n    defined at\n     src/sde/sde_tableaus.jl:75    #  DifferentialEquations.constructSRIW1     Function .  constructSRIW1()  Constructs the tableau type for the SRIW1 method.  source  Methods   \n     constructSRIW1 ( ) \n    defined at\n     src/sde/sde_tableaus.jl:41    #  DifferentialEquations.checkSRAOrder     Function .  checkSRAOrder(RosslerSRI)  Determines whether the order conditions are met via the tableaus of the SRA method.  source  Methods   \n     checkSRAOrder ( SRA ) \n    defined at\n     src/sde/sde_tableaus.jl:130    #  DifferentialEquations.checkSRIOrder     Function .  checkSRIOrder(RosslerSRI)  Determines whether the order conditions are met via the tableaus of the SRI method.  source  Methods   \n     checkSRIOrder ( RosslerSRI ) \n    defined at\n     src/sde/sde_tableaus.jl:93", 
            "title": "SDE Solver Extras"
        }, 
        {
            "location": "/internals/solver_helpers/#stationary-stokes", 
            "text": "#  DifferentialEquations.GS\u03b4q!     Function .  GS\u03b4q!(\u03b4q,rp,\u0394xs)  Performs a Gauss-Seidel iteration for \u03b4q.  source  Methods   \n     GS\u03b4q! ( \n     \u03b4q ,      rp ,      \u0394xs  ) \n    defined at\n     src/fdm/stokes_solve.jl:77    #  DifferentialEquations.GSu!     Function .  GSu!(u,f\u2081,\u0394xs,p,ugD,grids,ux,uy)  Performs a Gauss-Seidel iteration on u.  source  Methods   \n     GSu! ( \n     u ,      f\u2081 ,      \u0394xs ,      p ,      ugD ,      grids ,      ux ,      uy  ) \n    defined at\n     src/fdm/stokes_solve.jl:7    #  DifferentialEquations.calc_rp!     Function .  calc_rp!(rp,u,v,\u0394xs,g,px,py)  Calculates the rp from the u and v's.  source  Methods   \n     calc_rp! ( \n     rp ,      u ,      v ,      \u0394xs ,      g ,      px ,      py  ) \n    defined at\n     src/fdm/stokes_solve.jl:55    #  DifferentialEquations.update_p!     Function .  update_p!(p,\u03b4q,\u0394xs)  Updates p given \u03b4q  source  Methods   \n     update_p! ( \n     p ,      \u03b4q ,      \u0394xs  ) \n    defined at\n     src/fdm/stokes_solve.jl:131    #  DifferentialEquations.update_v!     Function .  update_v!(v,\u03b4q,\u0394xs)  Updates v given \u03b4q  source  Methods   \n     update_v! ( \n     v ,      \u03b4q ,      \u0394xs  ) \n    defined at\n     src/fdm/stokes_solve.jl:120    #  DifferentialEquations.uzawa_p!     Function .  uzawa_p!(p,u,v,\u0394xs,g,px,py)  Solves for p from u and v using an Uzawa update.  source  Methods   \n     uzawa_p! ( \n     p ,      u ,      v ,      \u0394xs ,      g ,      px ,      py  ) \n    defined at\n     src/fdm/stokes_solve.jl:66    #  DifferentialEquations.stokes_restriction     Function .  stokes_restriction(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)  Restricts the Stokes problem to the coarsegrid.  source  Methods   \n     stokes_restriction ( \n     u ,      v ,      p ,      \u0394xs ,      grids ,      mins ,      maxs ,      ugD ,      vgD  ) \n    defined at\n     src/fdm/stokes_solve.jl:163    #  DifferentialEquations.stokes_prolongation     Function .  stokes_prolongation(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)  Prolongates the Stokes problem to the fine grid  source  Methods   \n     stokes_prolongation ( \n     u ,      v ,      p ,      \u0394xs ,      grids ,      mins ,      maxs ,      ugD ,      vgD  ) \n    defined at\n     src/fdm/stokes_solve.jl:205    #  DifferentialEquations.update_u!     Function .  update_u!(u,\u03b4q,\u0394xs)  Updates u given \u03b4q  source  Methods   \n     update_u! ( \n     u ,      \u03b4q ,      \u0394xs  ) \n    defined at\n     src/fdm/stokes_solve.jl:109    #  DifferentialEquations.GSv!     Function .  GSv!(v,f\u2082,\u0394xs,p,vgD,grids,vx,vy)  Performs a Gauss-Seidel iteration on v.  source  Methods   \n     GSv! ( \n     v ,      f\u2082 ,      \u0394xs ,      p ,      vgD ,      grids ,      vx ,      vy  ) \n    defined at\n     src/fdm/stokes_solve.jl:31", 
            "title": "Stationary Stokes"
        }
    ]
}